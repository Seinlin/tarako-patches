From 76855535200651a875e5545096f0df4404ff7a9c Mon Sep 17 00:00:00 2001
From: Kai-Zhen Li <kli@mozilla.com>
Date: Tue, 29 Apr 2014 10:03:12 +0800
Subject: [PATCH] Bug 977026 - WIP.

---
 b2g/app/B2GLoader.cpp                              |  119 ++++++
 b2g/app/moz.build                                  |    5 +
 b2g/app/nsBrowserApp.cpp                           |   34 +-
 b2g/confvars.sh                                    |    1 +
 configure.in                                       |    8 +
 ipc/app/Makefile.in                                |    6 +
 ipc/app/MozillaRuntimeMain.cpp                     |  135 +------
 ipc/app/moz.build                                  |    2 +
 ipc/chromium/src/base/process_util_linux.cc        |   55 +++
 ipc/chromium/src/base/thread.cc                    |    6 +-
 ipc/contentproc/moz.build                          |   28 ++
 ipc/contentproc/plugin-container.cpp               |  153 ++++++++
 ipc/glue/PProcLoader.ipdl                          |   27 ++
 ipc/glue/ProcessUtils.h                            |   16 +
 ipc/glue/ProcessUtils_linux.cpp                    |  410 ++++++++++++++++++++
 ipc/glue/moz.build                                 |    5 +
 ipc/moz.build                                      |    3 +
 toolkit/xre/moz.build                              |    9 +
 toolkit/xre/nsAppRunner.cpp                        |    8 +
 toolkit/xre/nsEmbedFunctions.cpp                   |   25 ++
 tools/profiler/GeckoProfiler.h                     |    3 +
 tools/profiler/GeckoProfilerFunc.h                 |    2 +
 tools/profiler/GeckoProfilerImpl.h                 |    5 +
 tools/profiler/platform.cpp                        |    5 +
 xpcom/build/nsXULAppAPI.h                          |    9 +
 xpcom/components/ManifestParser.cpp                |   70 +++-
 xpcom/components/ManifestParser.h                  |    2 +-
 xpcom/components/nsComponentManager.cpp            |  171 ++++++--
 xpcom/components/nsComponentManager.h              |    4 +
 .../xptinfo/public/XPTInterfaceInfoManager.h       |   21 +
 xpcom/threads/BackgroundHangMonitor.cpp            |   49 ++-
 xpcom/threads/BackgroundHangMonitor.h              |   13 +
 32 files changed, 1218 insertions(+), 191 deletions(-)
 create mode 100644 b2g/app/B2GLoader.cpp
 create mode 100644 ipc/contentproc/moz.build
 create mode 100644 ipc/contentproc/plugin-container.cpp
 create mode 100644 ipc/glue/PProcLoader.ipdl

diff --git a/b2g/app/B2GLoader.cpp b/b2g/app/B2GLoader.cpp
new file mode 100644
index 0000000..0e1fe7c
--- /dev/null
+++ b/b2g/app/B2GLoader.cpp
@@ -0,0 +1,119 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set sw=2 ts=2 autoindent cindent expandtab: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "nsXULAppAPI.h"
+#include "nsXPCOMGlue.h"
+#include "nsStringGlue.h"
+#include "nsCOMPtr.h"
+#include "nsIFile.h"
+#include "BinaryPath.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+
+#include <dlfcn.h>
+
+#include "nsXPCOMPrivate.h" // for MAXPATHLEN and XPCOM_DLL
+
+
+#define ASSERT(x)  MOZ_ASSERT(x)
+
+
+// Functions being loaded by XPCOMGlue
+XRE_InitChildProcessType XRE_InitChildProcess;
+XRE_ProcLoaderServiceRunType XRE_ProcLoaderServiceRun;
+XRE_ProcLoaderInitType XRE_ProcLoaderInit;
+
+static const nsDynamicFunctionLoad kXULFuncs[] = {
+  { "XRE_InitChildProcess", (NSFuncPtr*) &XRE_InitChildProcess },
+  { "XRE_ProcLoaderServiceRun", (NSFuncPtr*) &XRE_ProcLoaderServiceRun },
+  { "XRE_ProcLoaderInit", (NSFuncPtr*) &XRE_ProcLoaderInit },
+  { nullptr, nullptr }
+};
+
+static int
+getProgramDir(const char *aProgram, char *aOutDirName, int aMaxLen) {
+  nsresult rv = mozilla::BinaryPath::Get(aProgram, aOutDirName);
+  char *lastSlash = strrchr(aOutDirName, XPCOM_FILE_PATH_SEPARATOR[0]);
+  if (!lastSlash ||
+      ((lastSlash - aOutDirName) + sizeof(XPCOM_DLL) + 1 > aMaxLen))
+    return 255;
+  strcpy(++lastSlash, XPCOM_DLL);
+  return 0;
+}
+
+static int
+loadSharedData(const char *aProgram) {
+  char programDir[MAXPATHLEN];
+  int ecode = getProgramDir(aProgram, programDir, MAXPATHLEN);
+  if (ecode) return ecode;
+
+  nsresult rv;
+
+  XPCOMGlueEnablePreload();
+  rv = XPCOMGlueStartup(programDir);
+  if (NS_FAILED(rv)) {
+    return 255;
+  }
+
+  rv = XPCOMGlueLoadXULFunctions(kXULFuncs);
+  if (NS_FAILED(rv)) {
+    return 255;
+  }
+
+  return 0;
+}
+
+static int
+forkParentChild(int argc, const char *argv[]) {
+  extern int b2g_main(int argc, const char *argv[]);
+
+  int sockets[2] = {-1, -1};
+  int r = socketpair(AF_LOCAL, SOCK_STREAM, 0, sockets);
+  ASSERT(r == 0);
+  int parentSock = sockets[0];
+  int childSock = sockets[1];
+
+  r = fcntl(parentSock, F_SETFL, O_NONBLOCK);
+  ASSERT(r != -1);
+  r = fcntl(childSock, F_SETFL, O_NONBLOCK);
+  ASSERT(r != -1);
+
+  pid_t pid = fork();
+  ASSERT(pid >= 0);
+  bool isChildProcess = pid == 0;
+
+  close(isChildProcess ? parentSock : childSock);
+
+  if (isChildProcess) {
+    return XRE_ProcLoaderServiceRun(getppid(), childSock, argc, argv);
+  }
+
+  int childPid = pid;
+  XRE_ProcLoaderInit(childPid, parentSock);
+  return b2g_main(argc, argv);
+}
+
+/**
+ * The loader of the b2g process and the Nuwa process.
+ *
+ * This loader make it possible to share memory of relocation tables
+ * of SOs and static data among b2g, Nuwa and content processes.
+ */
+int
+main(int argc, const char* argv[]) {
+  const char *program = argv[0];
+  int r = loadSharedData(program);
+  if (r) {
+    return r;
+  }
+
+  return forkParentChild(argc, argv);
+}
diff --git a/b2g/app/moz.build b/b2g/app/moz.build
index cd85ac9..a33ab8d 100644
--- a/b2g/app/moz.build
+++ b/b2g/app/moz.build
@@ -9,6 +9,11 @@ if not CONFIG['LIBXUL_SDK']:
         PROGRAM = CONFIG['MOZ_APP_NAME'] + "-bin"
     else:
         PROGRAM = CONFIG['MOZ_APP_NAME']
+    if CONFIG['MOZ_B2G_LOADER']:
+        SOURCES += [
+            'B2GLoader.cpp',
+        ]
+
     SOURCES += [
         'nsBrowserApp.cpp',
     ]
diff --git a/b2g/app/nsBrowserApp.cpp b/b2g/app/nsBrowserApp.cpp
index 83c2976..6632143 100644
--- a/b2g/app/nsBrowserApp.cpp
+++ b/b2g/app/nsBrowserApp.cpp
@@ -17,6 +17,7 @@
 
 #include <stdio.h>
 #include <stdarg.h>
+#include <string.h>
 
 #include "nsCOMPtr.h"
 #include "nsIFile.h"
@@ -163,9 +164,17 @@ static int do_main(int argc, char* argv[])
   return XRE_main(argc, argv, &sAppData, 0);
 }
 
-int main(int argc, char* argv[])
+#ifndef MOZ_B2G_LOADER
+#define MAIN main
+#else
+#define MAIN b2g_main
+#endif
+
+int MAIN(int argc, const char* argv[])
 {
+#ifndef MOZ_B2G_LOADER
   char exePath[MAXPATHLEN];
+#endif
 
 #ifdef MOZ_WIDGET_GONK
   // This creates a ThreadPool for binder ipc. A ThreadPool is necessary to
@@ -175,7 +184,9 @@ int main(int argc, char* argv[])
   android::ProcessState::self()->startThreadPool();
 #endif
 
-  nsresult rv = mozilla::BinaryPath::Get(argv[0], exePath);
+  nsresult rv;
+#ifndef MOZ_B2G_LOADER
+  rv = mozilla::BinaryPath::Get(argv[0], exePath);
   if (NS_FAILED(rv)) {
     Output("Couldn't calculate the application directory.\n");
     return 255;
@@ -186,6 +197,7 @@ int main(int argc, char* argv[])
     return 255;
 
   strcpy(++lastSlash, XPCOM_DLL);
+#endif // MOZ_B2G_LOADER
 
 #if defined(XP_UNIX)
   // If the b2g app is launched from adb shell, then the shell will wind
@@ -205,6 +217,7 @@ int main(int argc, char* argv[])
   gotCounters = GetProcessIoCounters(GetCurrentProcess(), &ioCounters);
 #endif
 
+#ifndef MOZ_B2G_LOADER
   // We do this because of data in bug 771745
   XPCOMGlueEnablePreload();
 
@@ -215,6 +228,7 @@ int main(int argc, char* argv[])
   }
   // Reset exePath so that it is the directory name and not the xpcom dll name
   *lastSlash = 0;
+#endif
 
   rv = XPCOMGlueLoadXULFunctions(kXULFuncs);
   if (NS_FAILED(rv)) {
@@ -253,7 +267,21 @@ int main(int argc, char* argv[])
   int result;
   {
     ScopedLogging log;
-    result = do_main(argc, argv);
+    char **_argv;
+
+    _argv = new char *[argc + 1];
+    for (int i = 0; i < argc; i++) {
+      _argv[i] = strdup(argv[i]);
+      MOZ_ASSERT(_argv[i] != nullptr);
+    }
+    _argv[argc] = nullptr;
+
+    result = do_main(argc, _argv);
+
+    for (int i = 0; i < argc; i++) {
+      free(_argv[i]);
+    }
+    delete _argv;
   }
 
   return result;
diff --git a/b2g/confvars.sh b/b2g/confvars.sh
index 7497080..aa7dcd7 100644
--- a/b2g/confvars.sh
+++ b/b2g/confvars.sh
@@ -58,5 +58,6 @@ MOZ_B2G=1
 
 if test "$OS_TARGET" = "Android"; then
 MOZ_NUWA_PROCESS=1
+MOZ_B2G_LOADER=1
 fi
 MOZ_FOLD_LIBS=1
diff --git a/configure.in b/configure.in
index f15a801..1c38718 100644
--- a/configure.in
+++ b/configure.in
@@ -8554,6 +8554,14 @@ if test "$MOZ_WIDGET_TOOLKIT" = gonk -a -n "$MOZ_NUWA_PROCESS"; then
     AC_DEFINE(MOZ_NUWA_PROCESS)
 fi
 AC_SUBST(MOZ_NUWA_PROCESS)
+if test "$MOZ_WIDGET_TOOLKIT" = gonk -a -n "$MOZ_B2G_LOADER"; then
+    if test -z "$MOZ_NUWA_PROCESS"; then
+       AC_MSG_ERROR([B2G loader is only work with Nuwa]);
+    fi
+    export MOZ_B2G_LOADER
+    AC_DEFINE(MOZ_B2G_LOADER)
+fi
+AC_SUBST(MOZ_B2G_LOADER)
 
 AC_SUBST(NSPR_CFLAGS)
 AC_SUBST(NSPR_LIBS)
diff --git a/ipc/app/Makefile.in b/ipc/app/Makefile.in
index 2904e5a..b32793d 100644
--- a/ipc/app/Makefile.in
+++ b/ipc/app/Makefile.in
@@ -47,6 +47,12 @@ endif
 
 include $(topsrcdir)/config/rules.mk
 
+include $(DEPTH)/config/autoconf.mk
+
+ifneq ($(MOZ_WIDGET_TOOLKIT),android)
+LIBS += ../contentproc/$(LIB_PREFIX)plugin-container.$(LIB_SUFFIX)
+endif
+
 LDFLAGS += $(MOZ_ALLOW_HEAP_EXECUTE_FLAGS)
 
 ifeq ($(OS_ARCH),WINNT) #{
diff --git a/ipc/app/MozillaRuntimeMain.cpp b/ipc/app/MozillaRuntimeMain.cpp
index fdf008a..205a3c1 100644
--- a/ipc/app/MozillaRuntimeMain.cpp
+++ b/ipc/app/MozillaRuntimeMain.cpp
@@ -4,138 +4,9 @@
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
 
-#include "nsXPCOM.h"
-#include "nsXULAppAPI.h"
-
-// FIXME/cjones testing
-#if !defined(OS_WIN)
-#include <unistd.h>
-#endif
-
-#ifdef XP_WIN
-#include <windows.h>
-// we want a wmain entry point
-// but we don't want its DLL load protection, because we'll handle it here
-#define XRE_DONT_PROTECT_DLL_LOAD
-#include "nsWindowsWMain.cpp"
-#include "nsSetDllDirectory.h"
-#endif
-
-#if defined(XP_WIN) && defined(MOZ_CONTENT_SANDBOX)
-#include "sandbox/base/basictypes.h"
-#include "sandbox/win/src/sandbox.h"
-#include "sandbox/win/src/sandbox_factory.h"
-#endif
-
-#ifdef MOZ_WIDGET_GONK
-# include <sys/time.h>
-# include <sys/resource.h> 
-
-# include <binder/ProcessState.h>
-
-# ifdef LOGE_IF
-#  undef LOGE_IF
-# endif
-
-# include <android/log.h>
-# define LOGE_IF(cond, ...) \
-     ( (CONDITION(cond)) \
-     ? ((void)__android_log_print(ANDROID_LOG_ERROR, \
-       "Gecko:MozillaRntimeMain", __VA_ARGS__)) \
-     : (void)0 )
-
-#endif
-
-#ifdef MOZ_NUWA_PROCESS
-#include <binder/ProcessState.h>
-#include "ipc/Nuwa.h"
-#endif
-
-#ifdef MOZ_WIDGET_GONK
-static void
-InitializeBinder(void *aDummy) {
-    // Change thread priority to 0 only during calling ProcessState::self().
-    // The priority is registered to binder driver and used for default Binder
-    // Thread's priority. 
-    // To change the process's priority to small value need's root permission.
-    int curPrio = getpriority(PRIO_PROCESS, 0);
-    int err = setpriority(PRIO_PROCESS, 0, 0);
-    MOZ_ASSERT(!err);
-    LOGE_IF(err, "setpriority failed. Current process needs root permission.");
-    android::ProcessState::self()->startThreadPool();
-    setpriority(PRIO_PROCESS, 0, curPrio);
-}
-#endif
+extern int content_process_main(int argc, char *argv[]);
 
 int
-main(int argc, char* argv[])
-{
-    bool isNuwa = false;
-    bool isSandboxEnabled = false;
-    for (int i = 1; i < argc; i++) {
-        isNuwa |= strcmp(argv[i], "-nuwa") == 0;
-        isSandboxEnabled |= strcmp(argv[i], "-sandbox") == 0;
-    }
-
-#ifdef MOZ_NUWA_PROCESS
-    if (isNuwa) {
-        PrepareNuwaProcess();
-    }
-#endif
-
-#ifdef MOZ_WIDGET_GONK
-    // This creates a ThreadPool for binder ipc. A ThreadPool is necessary to
-    // receive binder calls, though not necessary to send binder calls.
-    // ProcessState::Self() also needs to be called once on the main thread to
-    // register the main thread with the binder driver.
-
-#ifdef MOZ_NUWA_PROCESS
-    if (!isNuwa) {
-        InitializeBinder(nullptr);
-    } else {
-        NuwaAddFinalConstructor(&InitializeBinder, nullptr);
-    }
-#else
-    InitializeBinder(nullptr);
-#endif
-#endif
-
-#if defined(XP_WIN) && defined(MOZ_CONTENT_SANDBOX)
-    if (isSandboxEnabled) {
-        sandbox::TargetServices* target_service =
-            sandbox::SandboxFactory::GetTargetServices();
-        if (!target_service) {
-            return 1;
-        }
-
-        sandbox::ResultCode result = target_service->Init();
-        if (result != sandbox::SBOX_ALL_OK) {
-            return 2;
-        }
-
-        // Initialization is finished, switch to the lowered token
-        target_service->LowerToken();
-    }
-#endif
-
-    // Check for the absolute minimum number of args we need to move
-    // forward here. We expect the last arg to be the child process type.
-    if (argc < 1)
-      return 3;
-    GeckoProcessType proctype = XRE_StringToChildProcessType(argv[--argc]);
-
-#ifdef XP_WIN
-    // For plugins, this is done in PluginProcessChild::Init, as we need to
-    // avoid it for unsupported plugins.  See PluginProcessChild::Init for
-    // the details.
-    if (proctype != GeckoProcessType_Plugin) {
-        mozilla::SanitizeEnvironmentVariables();
-        SetDllDirectory(L"");
-    }
-#endif
-
-    nsresult rv = XRE_InitChildProcess(argc, argv, proctype);
-    NS_ENSURE_SUCCESS(rv, 1);
-
-    return 0;
+main(int argc, char *argv[]) {
+    return content_process_main(argc, argv);
 }
diff --git a/ipc/app/moz.build b/ipc/app/moz.build
index c455f52..d98133f 100644
--- a/ipc/app/moz.build
+++ b/ipc/app/moz.build
@@ -17,3 +17,5 @@ else:
     ]
 include('/ipc/chromium/chromium-config.mozbuild')
 
+if CONFIG['MOZ_B2G_LOADER']:
+    DEFINES['MOZ_B2G_LOADER'] = True
diff --git a/ipc/chromium/src/base/process_util_linux.cc b/ipc/chromium/src/base/process_util_linux.cc
index 5b95525..e5fb26b 100644
--- a/ipc/chromium/src/base/process_util_linux.cc
+++ b/ipc/chromium/src/base/process_util_linux.cc
@@ -1,3 +1,5 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set sw=2 ts=2 autoindent cindent expandtab: */
 // Copyright (c) 2008 The Chromium Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
@@ -19,6 +21,13 @@
 #include "base/logging.h"
 #include "base/string_tokenizer.h"
 #include "base/string_util.h"
+#include "nsLiteralString.h"
+
+#ifdef MOZ_B2G_LOADER
+#include "ProcessUtils.h"
+
+using namespace mozilla::ipc;
+#endif	// MOZ_B2G_LOADER
 
 #ifdef MOZ_WIDGET_GONK
 /*
@@ -189,12 +198,58 @@ bool LaunchApp(const std::vector<std::string>& argv,
                    wait, process_handle);
 }
 
+#ifdef MOZ_B2G_LOADER
+static bool
+LaunchAppProcLoader(const std::vector<std::string>& argv,
+                    const file_handle_mapping_vector& fds_to_remap,
+                    const environment_map& env_vars_to_set,
+                    ChildPrivileges privs,
+                    ProcessHandle* process_handle) {
+  size_t i;
+  scoped_array<char*> argv_cstr(new char*[argv.size() + 1]);
+  for (i = 0; i < argv.size(); i++) {
+    argv_cstr[i] = const_cast<char*>(argv[i].c_str());
+  }
+  argv_cstr[argv.size()] = NULL;
+
+  scoped_array<char*> env_cstr(new char*[env_vars_to_set.size()]);
+  i = 0;
+  for (environment_map::const_iterator it = env_vars_to_set.begin();
+       it != env_vars_to_set.end(); ++it) {
+    env_cstr[i++] = strdup((it->first + "=" + it->second).c_str());
+  }
+  env_cstr[env_vars_to_set.size()] = nullptr;
+
+  bool ok = ProcLoaderLoad((const char **)argv_cstr.get(),
+                           (const char **)env_cstr.get(),
+                           fds_to_remap, privs,
+                           process_handle);
+  MOZ_ASSERT(ok, "ProcLoaderLoad() failed");
+
+  for (size_t i = 0; i < env_vars_to_set.size(); i++) {
+    free(env_cstr[i]);
+  }
+
+  return ok;
+}
+#endif // MOZ_B2G_LOADER
+
 bool LaunchApp(const std::vector<std::string>& argv,
                const file_handle_mapping_vector& fds_to_remap,
                const environment_map& env_vars_to_set,
                ChildPrivileges privs,
                bool wait, ProcessHandle* process_handle,
                ProcessArchitecture arch) {
+#ifdef MOZ_B2G_LOADER
+  static bool firstTimeProcLoader = true;
+
+  if (!wait && firstTimeProcLoader) {
+    firstTimeProcLoader = false;
+    return LaunchAppProcLoader(argv, fds_to_remap, env_vars_to_set,
+                               privs, process_handle);
+  }
+#endif // MOZ_B2G_LOADER
+
   scoped_array<char*> argv_cstr(new char*[argv.size() + 1]);
   // Illegal to allocate memory after fork and before execvp
   InjectiveMultimap fd_shuffle1, fd_shuffle2;
diff --git a/ipc/chromium/src/base/thread.cc b/ipc/chromium/src/base/thread.cc
index c908f78..b8055d7 100644
--- a/ipc/chromium/src/base/thread.cc
+++ b/ipc/chromium/src/base/thread.cc
@@ -138,7 +138,8 @@ void Thread::StopSoon() {
 
 void Thread::ThreadMain() {
   char aLocal;
-  profiler_register_thread(name_.c_str(), &aLocal);
+  if (profiler_is_init())
+    profiler_register_thread(name_.c_str(), &aLocal);
 
   // The message loop for this thread.
   MessageLoop message_loop(startup_data_->options.message_loop_type);
@@ -167,7 +168,8 @@ void Thread::ThreadMain() {
   // Assert that MessageLoop::Quit was called by ThreadQuitTask.
   DCHECK(GetThreadWasQuitProperly());
 
-  profiler_unregister_thread();
+  if (profiler_is_init())
+    profiler_unregister_thread();
 
   // We can't receive messages anymore.
   message_loop_ = NULL;
diff --git a/ipc/contentproc/moz.build b/ipc/contentproc/moz.build
new file mode 100644
index 0000000..64bd1c3
--- /dev/null
+++ b/ipc/contentproc/moz.build
@@ -0,0 +1,28 @@
+# -*- Mode: python; c-basic-offset: 4; indent-tabs-mode: nil; tab-width: 40 -*-
+# vim: set filetype=python:
+# This Source Code Form is subject to the terms of the Mozilla Public
+# License, v. 2.0. If a copy of the MPL was not distributed with this
+# file, You can obtain one at http://mozilla.org/MPL/2.0/.
+
+LIBRARY_NAME = 'plugin-container'
+if CONFIG['MOZ_B2G_LOADER']:
+    FINAL_LIBRARY = 'xul'
+
+SOURCES += [
+    'plugin-container.cpp',
+]
+
+include('/ipc/chromium/chromium-config.mozbuild')
+
+LOCAL_INCLUDES += [
+    '/toolkit/xre',
+    '/xpcom/base',
+]
+
+if CONFIG['MOZ_CONTENT_SANDBOX'] and CONFIG['OS_ARCH'] == 'WINNT':
+    # For sandbox includes and the include dependencies those have
+    LOCAL_INCLUDES += [
+        '/security',
+        '/security/sandbox',
+        '/security/sandbox/chromium',
+    ]
diff --git a/ipc/contentproc/plugin-container.cpp b/ipc/contentproc/plugin-container.cpp
new file mode 100644
index 0000000..e5cba3a
--- /dev/null
+++ b/ipc/contentproc/plugin-container.cpp
@@ -0,0 +1,153 @@
+/* -*- Mode: C++; tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 4 -*-
+ * vim: sw=4 ts=4 et :
+ * This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "nsXPCOM.h"
+#include "nsXULAppAPI.h"
+
+// FIXME/cjones testing
+#if !defined(OS_WIN)
+#include <unistd.h>
+#endif
+
+#ifdef XP_WIN
+#include <windows.h>
+// we want a wmain entry point
+// but we don't want its DLL load protection, because we'll handle it here
+#define XRE_DONT_PROTECT_DLL_LOAD
+#include "nsWindowsWMain.cpp"
+#include "nsSetDllDirectory.h"
+#endif
+
+#if defined(XP_WIN) && defined(MOZ_CONTENT_SANDBOX)
+#include "sandbox/chromium/base/basictypes.h"
+#include "sandbox/win/src/sandbox.h"
+#include "sandbox/win/src/sandbox_factory.h"
+#include "mozilla/sandboxTarget.h"
+#endif
+
+#ifdef MOZ_WIDGET_GONK
+# include <sys/time.h>
+# include <sys/resource.h> 
+
+# include <binder/ProcessState.h>
+
+# ifdef LOGE_IF
+#  undef LOGE_IF
+# endif
+
+# include <android/log.h>
+# define LOGE_IF(cond, ...) \
+     ( (CONDITION(cond)) \
+     ? ((void)__android_log_print(ANDROID_LOG_ERROR, \
+       "Gecko:MozillaRntimeMain", __VA_ARGS__)) \
+     : (void)0 )
+
+#endif
+
+#ifdef MOZ_NUWA_PROCESS
+#include <binder/ProcessState.h>
+#include "ipc/Nuwa.h"
+#endif
+
+#ifdef MOZ_WIDGET_GONK
+static void
+InitializeBinder(void *aDummy) {
+    // Change thread priority to 0 only during calling ProcessState::self().
+    // The priority is registered to binder driver and used for default Binder
+    // Thread's priority. 
+    // To change the process's priority to small value need's root permission.
+    int curPrio = getpriority(PRIO_PROCESS, 0);
+    int err = setpriority(PRIO_PROCESS, 0, 0);
+    MOZ_ASSERT(!err);
+    LOGE_IF(err, "setpriority failed. Current process needs root permission.");
+    android::ProcessState::self()->startThreadPool();
+    setpriority(PRIO_PROCESS, 0, curPrio);
+}
+#endif
+
+#if defined(XP_WIN) && defined(MOZ_CONTENT_SANDBOX)
+static bool gIsSandboxEnabled = false;
+void StartSandboxCallback()
+{
+    if (gIsSandboxEnabled) {
+        sandbox::TargetServices* target_service =
+            sandbox::SandboxFactory::GetTargetServices();
+        target_service->LowerToken();
+    }
+}
+#endif
+
+int
+content_process_main(int argc, char* argv[])
+{
+    bool isNuwa = false;
+    for (int i = 1; i < argc; i++) {
+        isNuwa |= strcmp(argv[i], "-nuwa") == 0;
+#if defined(XP_WIN) && defined(MOZ_CONTENT_SANDBOX)
+        gIsSandboxEnabled |= strcmp(argv[i], "-sandbox") == 0;
+#endif
+    }
+
+#ifdef MOZ_NUWA_PROCESS
+    if (isNuwa) {
+        PrepareNuwaProcess();
+    }
+#endif
+
+#ifdef MOZ_WIDGET_GONK
+    // This creates a ThreadPool for binder ipc. A ThreadPool is necessary to
+    // receive binder calls, though not necessary to send binder calls.
+    // ProcessState::Self() also needs to be called once on the main thread to
+    // register the main thread with the binder driver.
+
+#ifdef MOZ_NUWA_PROCESS
+    if (!isNuwa) {
+        InitializeBinder(nullptr);
+    } else {
+        NuwaAddFinalConstructor(&InitializeBinder, nullptr);
+    }
+#else
+    InitializeBinder(nullptr);
+#endif
+#endif
+
+    // Check for the absolute minimum number of args we need to move
+    // forward here. We expect the last arg to be the child process type.
+    if (argc < 1)
+      return 3;
+    GeckoProcessType proctype = XRE_StringToChildProcessType(argv[--argc]);
+
+#ifdef XP_WIN
+    // For plugins, this is done in PluginProcessChild::Init, as we need to
+    // avoid it for unsupported plugins.  See PluginProcessChild::Init for
+    // the details.
+    if (proctype != GeckoProcessType_Plugin) {
+        mozilla::SanitizeEnvironmentVariables();
+        SetDllDirectory(L"");
+    }
+
+#ifdef MOZ_CONTENT_SANDBOX
+    if (gIsSandboxEnabled) {
+        sandbox::TargetServices* target_service =
+            sandbox::SandboxFactory::GetTargetServices();
+        if (!target_service) {
+            return 1;
+        }
+
+        sandbox::ResultCode result = target_service->Init();
+        if (result != sandbox::SBOX_ALL_OK) {
+           return 2;
+        }
+        mozilla::SandboxTarget::Instance()->SetStartSandboxCallback(StartSandboxCallback);
+    }
+#endif
+#endif
+
+    nsresult rv = XRE_InitChildProcess(argc, argv, proctype);
+    NS_ENSURE_SUCCESS(rv, 1);
+
+    return 0;
+}
diff --git a/ipc/glue/PProcLoader.ipdl b/ipc/glue/PProcLoader.ipdl
new file mode 100644
index 0000000..924f3e84
--- /dev/null
+++ b/ipc/glue/PProcLoader.ipdl
@@ -0,0 +1,27 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set sw=2 ts=2 autoindent cindent expandtab: */
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this file,
+ * You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+namespace mozilla {
+namespace ipc {
+
+struct FDRemap {
+  FileDescriptor fd;
+  int mapto;
+};
+
+protocol PProcLoader
+{
+child:
+  async LoadSO(nsCString[] argv, nsCString[] env,
+               FDRemap[] fdsRemap, uint32_t privs,
+               int32_t cookie);
+
+parent:
+  async LoadComplete(int32_t pid, int32_t cookie);
+};
+
+}
+}
diff --git a/ipc/glue/ProcessUtils.h b/ipc/glue/ProcessUtils.h
index fc17609..9d6321e 100644
--- a/ipc/glue/ProcessUtils.h
+++ b/ipc/glue/ProcessUtils.h
@@ -1,3 +1,5 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set sw=2 ts=2 autoindent cindent expandtab: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
@@ -5,6 +7,10 @@
 #ifndef mozilla_ipc_ProcessUtils_h
 #define mozilla_ipc_ProcessUtils_h
 
+#ifdef MOZ_B2G_LOADER
+#include "base/process_util.h"
+#endif
+
 namespace mozilla {
 namespace ipc {
 
@@ -12,6 +18,16 @@ namespace ipc {
 // this directly.
 void SetThisProcessName(const char *aName);
 
+#ifdef MOZ_B2G_LOADER
+void ProcLoaderGeckoInit();
+
+bool ProcLoaderLoad(const char *aArgv[],
+                    const char *aEnvp[],
+                    const base::file_handle_mapping_vector &aFdsRemap,
+                    const base::ChildPrivileges aPrivs,
+                    base::ProcessHandle *aProcessHandle);
+#endif /* MOZ_B2G_LOADER */
+
 } // namespace ipc
 } // namespace mozilla
 
diff --git a/ipc/glue/ProcessUtils_linux.cpp b/ipc/glue/ProcessUtils_linux.cpp
index d5b8c09..0439f12 100644
--- a/ipc/glue/ProcessUtils_linux.cpp
+++ b/ipc/glue/ProcessUtils_linux.cpp
@@ -1,3 +1,5 @@
+/* -*- Mode: C++; tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- */
+/* vim: set sw=2 ts=2 autoindent cindent expandtab: */
 /* This Source Code Form is subject to the terms of the Mozilla Public
  * License, v. 2.0. If a copy of the MPL was not distributed with this
  * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
@@ -8,6 +10,35 @@
 
 #include <sys/prctl.h>
 
+#ifdef MOZ_B2G_LOADER
+
+#include <sys/types.h>
+#include <unistd.h>
+
+#include "nsAutoPtr.h"
+
+#include "mozilla/Assertions.h"
+#include "mozilla/ipc/PProcLoaderParent.h"
+#include "mozilla/ipc/PProcLoaderChild.h"
+#include "mozilla/ipc/Transport.h"
+#include "mozilla/ipc/FileDescriptorUtils.h"
+#include "mozilla/ipc/IOThreadChild.h"
+#include "mozilla/dom/ContentProcess.h"
+#include "base/file_descriptor_shuffle.h"
+#include "mozilla/BackgroundHangMonitor.h"
+#include "mozilla/DebugOnly.h"
+#include "base/process_util.h"
+
+#include "prenv.h"
+
+#include "nsXULAppAPI.h" // export XRE_* functions
+
+#include "nsAppRunner.h"
+
+int content_process_main(int argc, char *argv[]);
+
+#endif /* MOZ_B2G_LOADER */
+
 namespace mozilla {
 namespace ipc {
 
@@ -16,5 +47,384 @@ void SetThisProcessName(const char *aName)
   prctl(PR_SET_NAME, (unsigned long)aName, 0uL, 0uL, 0uL);
 }
 
+#ifdef MOZ_B2G_LOADER
+
+using namespace base;
+using namespace mozilla::dom;
+
+static bool sProcLoaderOnDestroy = false;
+static DebugOnly<bool> sProcLoaderInitialized = false;
+static DebugOnly<bool> sProcLoaderGeckoInitialized = false;
+static pid_t sProcLoaderPid = 0;
+static int sProcLoaderChannelFd = -1;
+static PProcLoaderParent *sProcLoaderParent = nullptr;
+
+static void ProcLoaderDeinit();
+
+
+class ProcLoaderParent : public PProcLoaderParent {
+private:
+  nsAutoPtr<FileDescriptor> mFd;
+
+public:
+  ProcLoaderParent(FileDescriptor *aFd) : mFd(aFd) {}
+
+  virtual bool RecvLoadComplete(const int32_t &aPid,
+                                const int32_t &aCookie);
+
+  virtual void OnChannelError();
+};
+
+static void
+_ProcLoaderParentDestroy(PProcLoaderParent *aLoader) {
+  aLoader->Close();
+  delete aLoader;
+}
+
+bool
+ProcLoaderParent::RecvLoadComplete(const int32_t &aPid,
+                                   const int32_t &aCookie)
+{
+  ProcLoaderDeinit();
+  return true;
+}
+
+void
+ProcLoaderParent::OnChannelError()
+{
+  ProcLoaderDeinit();
+}
+
+static void
+ProcLoaderInit(pid_t aPeerPid, int aChannelFd)
+{
+  MOZ_ASSERT(!sProcLoaderInitialized, "call ProcLoaderInit() more than once");
+  MOZ_ASSERT(aPeerPid != 0 && aChannelFd == -1, "invalid argument");
+  sProcLoaderPid = aPeerPid;
+  sProcLoaderChannelFd = aChannelFd;
+  sProcLoaderInitialized = true;
+}
+
+void
+ProcLoaderGeckoInit()
+{
+  MOZ_ASSERT(sProcLoaderInitialized, "call ProcLoaderInit() at first");
+  MOZ_ASSERT(!sProcLoaderGeckoInitialized,
+             "call ProcLoaderGeckoInit() more than once");
+
+  sProcLoaderGeckoInitialized = true;
+
+  FileDescriptor *fd = new FileDescriptor(sProcLoaderChannelFd);
+  close(sProcLoaderChannelFd);
+  sProcLoaderChannelFd = -1;
+  Transport *transport = OpenDescriptor(*fd, Transport::MODE_CLIENT);
+  sProcLoaderParent = new ProcLoaderParent(fd);
+  sProcLoaderParent->Open(transport,
+                          sProcLoaderPid,
+                          XRE_GetIOMessageLoop(),
+                          ParentSide);
+}
+
+static void
+ProcLoaderDeinit()
+{
+  if (sProcLoaderOnDestroy)
+    return;
+  MOZ_ASSERT(sProcLoaderGeckoInitialized && sProcLoaderInitialized);
+  sProcLoaderOnDestroy = true;
+  sProcLoaderGeckoInitialized = false;
+  sProcLoaderInitialized = false;
+
+  MOZ_ASSERT(sProcLoaderParent != nullptr);
+  PProcLoaderParent *procLoaderParent = sProcLoaderParent;
+  sProcLoaderParent = nullptr;
+
+  MessageLoop::current()->
+    PostTask(FROM_HERE,
+             NewRunnableFunction(&_ProcLoaderParentDestroy,
+                                 procLoaderParent));
+}
+
+bool
+ProcLoaderLoad(const char *aArgv[],
+               const char *aEnvp[],
+               const file_handle_mapping_vector &aFdsRemap,
+               const ChildPrivileges aPrivs,
+               ProcessHandle *aProcessHandle)
+{
+  static int cookie=0;
+  int i;
+
+  PProcLoaderParent *loader = sProcLoaderParent;
+  if (loader == nullptr) {
+    return false;
+  }
+
+  nsTArray<nsCString> argv;
+  for (i = 0; aArgv[i] != nullptr; i++) {
+    argv.AppendElement(nsCString(aArgv[i]));
+  }
+  nsTArray<nsCString> env;
+  for (i = 0; aEnvp[i] != nullptr; i++) {
+    env.AppendElement(nsCString(aEnvp[i]));
+  }
+  nsTArray<FDRemap> fdsremap;
+  for (file_handle_mapping_vector::const_iterator fdmap =
+         aFdsRemap.begin();
+       fdmap != aFdsRemap.end();
+       fdmap++) {
+    fdsremap.AppendElement(FDRemap(fdmap->first, fdmap->second));
+  }
+
+  bool ok = loader->SendLoadSO(argv, env, fdsremap, aPrivs,
+                               cookie++);
+  if (ok) {
+    MOZ_ASSERT(sProcLoaderPid != 0);
+    *aProcessHandle = sProcLoaderPid;
+    sProcLoaderPid = 0;
+  }
+
+  return ok;
+}
+
+
+class ProcLoaderRunnerBase;
+
+static bool sProcLoaderServing = false;
+static ProcLoaderRunnerBase *sProcLoaderLoadingTask = nullptr;
+
+class ProcLoaderRunnerBase {
+public:
+  virtual int DoWork() = 0;
+};
+
+
+class ProcLoaderRunnerExit : public ProcLoaderRunnerBase {
+public:
+  virtual int DoWork();
+};
+
+int
+ProcLoaderRunnerExit::DoWork() {
+  return 0;
+}
+
+
+class ProcLoaderRunnerLoad : public ProcLoaderRunnerBase {
+private:
+  const nsTArray<nsCString> mArgv;
+  const nsTArray<nsCString> mEnv;
+  const nsTArray<FDRemap> mFdsRemap;
+  const ChildPrivileges mPrivs;
+
+  void ArrangeFds();
+
+public:
+  ProcLoaderRunnerLoad(const InfallibleTArray<nsCString>& aArgv,
+                       const InfallibleTArray<nsCString>& aEnv,
+                       const InfallibleTArray<FDRemap>& aFdsRemap,
+                       const ChildPrivileges aPrivs)
+    : mArgv(aArgv)
+    , mEnv(aEnv)
+    , mFdsRemap(aFdsRemap)
+    , mPrivs(aPrivs) {}
+
+  int DoWork();
+};
+
+void
+ProcLoaderRunnerLoad::ArrangeFds() {
+  unsigned int i;
+
+  InjectiveMultimap fd_shuffle1, fd_shuffle2;
+  fd_shuffle1.reserve(mFdsRemap.Length());
+  fd_shuffle2.reserve(mFdsRemap.Length());
+  for (i = 0; i < mFdsRemap.Length(); i++) {
+    const FDRemap *map = &mFdsRemap[i];
+    int fd = map->fd().PlatformHandle();
+    int tofd = map->mapto();
+
+    fd_shuffle1.push_back(InjectionArc(fd, tofd, false));
+    fd_shuffle2.push_back(InjectionArc(fd, tofd, false));
+  }
+
+  DebugOnly<nsresult> rv = ShuffleFileDescriptors(&fd_shuffle1);
+  MOZ_ASSERT(NS_SUCCEEDED(rv), "ShuffleFileDescriptors failed");
+
+  CloseSuperfluousFds(fd_shuffle2);
+}
+
+int
+ProcLoaderRunnerLoad::DoWork() {
+  unsigned int i;
+
+  ArrangeFds();
+
+  unsigned int argc = mArgv.Length();
+  char **argv = new char *[argc + 1];
+  for (i = 0; i < argc; i++) {
+    argv[i] = ::strdup(mArgv[i].get());
+  }
+  argv[argc] = nullptr;
+
+  unsigned int envc = mEnv.Length();
+  for (i = 0; i < envc; i++) {
+    PR_SetEnv(mEnv[i].get());
+  }
+
+  SetCurrentProcessPrivileges(mPrivs);
+
+  MOZ_ASSERT(content_process_main != nullptr,
+             "content_process_main not found");
+  int ret = content_process_main(argc, argv);
+
+  for (i = 0; i < argc; i++) {
+    free(argv[i]);
+  }
+  delete argv;
+
+  return ret;
+}
+
+
+class ProcLoaderChild : public PProcLoaderChild
+{
+  pid_t mPeerPid;
+
+public:
+  ProcLoaderChild(pid_t aPeerPid) : mPeerPid(aPeerPid) {}
+
+  virtual bool RecvLoadSO(const InfallibleTArray<nsCString>& aArgv,
+                          const InfallibleTArray<nsCString>& aEnv,
+                          const InfallibleTArray<FDRemap>& aFdsremap,
+                          const uint32_t& aPrivs,
+                          const int32_t& aCookie);
+
+  virtual void OnChannelError();
+};
+
+static void
+_ProcLoaderChildDestroy(ProcLoaderChild *aChild) {
+  aChild->Close();
+  delete aChild;
+  MessageLoop::current()->Quit();
+}
+
+bool
+ProcLoaderChild::RecvLoadSO(const InfallibleTArray<nsCString>& aArgv,
+                            const InfallibleTArray<nsCString>& aEnv,
+                            const InfallibleTArray<FDRemap>& aFdsRemap,
+                            const uint32_t& aPrivs,
+                            const int32_t& aCookie) {
+  if (!sProcLoaderServing) {
+    return true;
+  }
+  sProcLoaderServing = false;
+
+  MOZ_ASSERT(sProcLoaderLoadingTask == nullptr);
+  ChildPrivileges privs = static_cast<ChildPrivileges>(aPrivs);
+  sProcLoaderLoadingTask =
+    new ProcLoaderRunnerLoad(aArgv, aEnv, aFdsRemap, privs);
+
+  SendLoadComplete(mPeerPid, aCookie);
+
+  MessageLoop::current()->PostTask(FROM_HERE,
+                                   NewRunnableFunction(_ProcLoaderChildDestroy,
+                                                       this));
+  return true;
+}
+
+void
+ProcLoaderChild::OnChannelError() {
+  if (!sProcLoaderServing) {
+    return;
+  }
+  sProcLoaderServing = false;
+
+  PProcLoaderChild::OnChannelError();
+
+  MOZ_ASSERT(sProcLoaderLoadingTask == nullptr);
+  sProcLoaderLoadingTask = new ProcLoaderRunnerExit();
+
+  MessageLoop::current()->PostTask(FROM_HERE,
+                                   NewRunnableFunction(_ProcLoaderChildDestroy,
+                                                       this));
+}
+
+static int
+ProcLoaderServiceRun(pid_t aPeerPid, int aFd,
+                     int aArgc, const char *aArgv[]) {
+  char **_argv;
+  _argv = new char *[aArgc + 1];
+  for (int i = 0; i < aArgc; i++) {
+    _argv[i] = ::strdup(aArgv[i]);
+    MOZ_ASSERT(_argv[i] != nullptr);
+  }
+  _argv[aArgc] = nullptr;
+
+  gArgv = _argv;
+  gArgc = aArgc;
+
+  {
+    nsresult rv = XRE_InitCommandLine(aArgc, _argv);
+    if (NS_FAILED(rv)) {
+      return NS_ERROR_FAILURE;
+    }
+
+    FileDescriptor fd(aFd);
+    close(aFd);
+
+    MOZ_ASSERT(!sProcLoaderServing);
+    MessageLoop loop;
+
+    nsAutoPtr<ContentProcess> process;
+    process = new ContentProcess(aPeerPid);
+    ChildThread *iothread = process->child_thread();
+
+    Transport *transport = OpenDescriptor(fd, Transport::MODE_CLIENT);
+    ProcLoaderChild *loaderChild = new ProcLoaderChild(aPeerPid);
+    // Pass a message loop to initialize (connect) the channel
+    // (connection).
+    loaderChild->Open(transport, aPeerPid, iothread->message_loop());
+
+    BackgroundHangMonitor::Prohibit();
+
+    sProcLoaderServing = true;
+    loop.Run();
+
+    BackgroundHangMonitor::Allow();
+
+    XRE_DeinitCommandLine();
+  }
+
+  MOZ_ASSERT(sProcLoaderLoadingTask != nullptr);
+  int ret = sProcLoaderLoadingTask->DoWork();
+  delete sProcLoaderLoadingTask;
+  sProcLoaderLoadingTask = nullptr;
+
+  for (int i = 0; i < aArgc; i++) {
+    free(_argv[i]);
+  }
+  delete _argv;
+
+  return ret;
+}
+
+#endif /* MOZ_B2G_LOADER */
+
 } // namespace ipc
 } // namespace mozilla
+
+#ifdef MOZ_B2G_LOADER
+void
+XRE_ProcLoaderInit(pid_t aPeerPid, int aChannelFd) {
+  mozilla::ipc::ProcLoaderInit(aPeerPid, aChannelFd);
+}
+
+int
+XRE_ProcLoaderServiceRun(pid_t aPeerPid, int aFd,
+                         int aArgc, const char *aArgv[]) {
+  return mozilla::ipc::ProcLoaderServiceRun(aPeerPid, aFd,
+                                            aArgc, aArgv);
+}
+#endif /* MOZ_B2G_LOADER */
diff --git a/ipc/glue/moz.build b/ipc/glue/moz.build
index 6e6e274..cdedbfa 100644
--- a/ipc/glue/moz.build
+++ b/ipc/glue/moz.build
@@ -99,10 +99,15 @@ SOURCES += [
 
 IPDL_SOURCES = [
     'InputStreamParams.ipdlh',
+    'PProcLoader.ipdl',
     'ProtocolTypes.ipdlh',
     'URIParams.ipdlh',
 ]
 
+LOCAL_INCLUDES += [
+    '/toolkit/xre',
+]
+
 include('/ipc/chromium/chromium-config.mozbuild')
 
 FINAL_LIBRARY = 'xul'
diff --git a/ipc/moz.build b/ipc/moz.build
index 471c235..f0ede71 100644
--- a/ipc/moz.build
+++ b/ipc/moz.build
@@ -26,4 +26,7 @@ if CONFIG['MOZ_B2G_RIL'] or CONFIG['MOZ_B2G_BT'] or CONFIG['MOZ_NFC'] or CONFIG[
 if CONFIG['MOZ_WIDGET_TOOLKIT'] == 'gonk':
     DIRS += ['netd', 'keystore']
 
+if CONFIG['MOZ_WIDGET_TOOLKIT'] != 'android':
+    DIRS += ['contentproc']
+
 TOOL_DIRS += ['app']
diff --git a/toolkit/xre/moz.build b/toolkit/xre/moz.build
index ad7901f..560cafe 100644
--- a/toolkit/xre/moz.build
+++ b/toolkit/xre/moz.build
@@ -144,3 +144,12 @@ for var in ('APP_VERSION', 'APP_ID'):
 
 if CONFIG['MOZILLA_OFFICIAL']:
     DEFINES['MOZILLA_OFFICIAL'] = True
+
+if CONFIG['MOZ_B2G_LOADER']:
+    LOCAL_INCLUDES += [
+        '/xpcom/components',
+    ]
+    GENERATED_INCLUDES += [
+        '/xpcom',
+    ]
+    DEFINES['OMNIJAR_NAME'] = CONFIG['OMNIJAR_NAME']
diff --git a/toolkit/xre/nsAppRunner.cpp b/toolkit/xre/nsAppRunner.cpp
index 90d6c51..b582526 100644
--- a/toolkit/xre/nsAppRunner.cpp
+++ b/toolkit/xre/nsAppRunner.cpp
@@ -201,6 +201,10 @@
 #include "GTestRunner.h"
 #endif
 
+#ifdef MOZ_B2G_LOADER
+#include "ProcessUtils.h"
+#endif
+
 #ifdef MOZ_WIDGET_ANDROID
 #include "AndroidBridge.h"
 #endif
@@ -3818,6 +3822,10 @@ XREMain::XRE_mainRun()
   nsresult rv = NS_OK;
   NS_ASSERTION(mScopedXPCom, "Scoped xpcom not initialized.");
 
+#ifdef MOZ_B2G_LOADER
+  mozilla::ipc::ProcLoaderGeckoInit();
+#endif
+
 #ifdef NS_FUNCTION_TIMER
   // initialize some common services, so we don't pay the cost for these at odd times later on;
   // SetWindowCreator -> ChromeRegistry -> IOService -> SocketTransportService -> (nspr wspm init), Prefs
diff --git a/toolkit/xre/nsEmbedFunctions.cpp b/toolkit/xre/nsEmbedFunctions.cpp
index 019ecde..5e62e4d 100644
--- a/toolkit/xre/nsEmbedFunctions.cpp
+++ b/toolkit/xre/nsEmbedFunctions.cpp
@@ -77,6 +77,12 @@
 using mozilla::_ipdltest::IPDLUnitTestProcessChild;
 #endif  // ifdef MOZ_IPDL_TESTS
 
+#ifdef MOZ_B2G_LOADER
+#include "nsDirectoryService.h"
+#include "nsComponentManager.h"
+#include "nsLocalFile.h"
+#endif
+
 using namespace mozilla;
 
 using mozilla::ipc::BrowserProcessSubThread;
@@ -797,3 +803,22 @@ XRE_GetWindowsEnvironment()
 }
 #endif // XP_WIN
 
+#ifdef MOZ_B2G_LOADER
+void
+XRE_ProcLoaderPreload() {
+    /* nsDirectoryService is required by nsComponentManagerImpl. */
+    nsDirectoryService::RealInit();
+    // omnijar in appDir
+    nsLocalFile* localFile = new nsLocalFile;
+    NS_ADDREF(localFile);
+    localFile->InitWithNativePath(NS_LITERAL_CSTRING(NS_STRINGIFY(OMNIJAR_NAME)));
+    Omnijar::Init(nullptr, localFile);
+
+    nsComponentManagerImpl::PreloadXPT();
+
+    Omnijar::CleanUp();
+    NS_RELEASE(localFile);
+    delete nsDirectoryService::gService;
+    nsDirectoryService::gService = nullptr;
+}
+#endif /* MOZ_B2G_LOADER */
diff --git a/tools/profiler/GeckoProfiler.h b/tools/profiler/GeckoProfiler.h
index f3971a3..d11bc2d 100644
--- a/tools/profiler/GeckoProfiler.h
+++ b/tools/profiler/GeckoProfiler.h
@@ -101,6 +101,9 @@ static inline void profiler_init(void* stackTop) {};
 // after this point and all pseudo labels should have been popped.
 static inline void profiler_shutdown() {};
 
+// Return if the profiler have been initialized.
+static inline bool profiler_is_init() { return false; };
+
 // Start the profiler with the selected options. The samples will be
 // recorded in a circular buffer.
 //   "aProfileEntries" is an abstract size indication of how big
diff --git a/tools/profiler/GeckoProfilerFunc.h b/tools/profiler/GeckoProfilerFunc.h
index 6e59cfa..e156103 100644
--- a/tools/profiler/GeckoProfilerFunc.h
+++ b/tools/profiler/GeckoProfilerFunc.h
@@ -58,6 +58,8 @@ void mozilla_sampler_init(void* stackTop);
 
 void mozilla_sampler_shutdown();
 
+bool mozilla_sampler_is_init();
+
 void mozilla_sampler_print_location1();
 void mozilla_sampler_print_location2();
 
diff --git a/tools/profiler/GeckoProfilerImpl.h b/tools/profiler/GeckoProfilerImpl.h
index e84eb3c..944fa7a 100644
--- a/tools/profiler/GeckoProfilerImpl.h
+++ b/tools/profiler/GeckoProfilerImpl.h
@@ -66,6 +66,11 @@ void profiler_shutdown()
 }
 
 static inline
+bool profiler_is_init() {
+  return mozilla_sampler_is_init();
+}
+
+static inline
 void profiler_start(int aProfileEntries, int aInterval,
                        const char** aFeatures, uint32_t aFeatureCount,
                        const char** aThreadNameFilters, uint32_t aFilterCount)
diff --git a/tools/profiler/platform.cpp b/tools/profiler/platform.cpp
index 5448c5b..5060d9a 100644
--- a/tools/profiler/platform.cpp
+++ b/tools/profiler/platform.cpp
@@ -542,6 +542,11 @@ void mozilla_sampler_shutdown()
   // TODO Need to find a safe time to delete Stack
 }
 
+bool mozilla_sampler_is_init()
+{
+  return sInitCount > 0;
+}
+
 void mozilla_sampler_save()
 {
   TableTicker *t = tlsTicker.get();
diff --git a/xpcom/build/nsXULAppAPI.h b/xpcom/build/nsXULAppAPI.h
index bf93e08..29d37f7 100644
--- a/xpcom/build/nsXULAppAPI.h
+++ b/xpcom/build/nsXULAppAPI.h
@@ -466,6 +466,15 @@ XRE_API(WindowsEnvironmentType,
         XRE_GetWindowsEnvironment, ())
 #endif // XP_WIN
 
+#ifdef MOZ_B2G_LOADER
+XRE_API(int,
+        XRE_ProcLoaderServiceRun, (pid_t, int, int argc, const char *argv[]));
+XRE_API(void,
+        XRE_ProcLoaderInit, (pid_t, int));
+XRE_API(void,
+        XRE_ProcLoaderPreload, ());
+#endif // MOZ_B2G_LOADER
+
 XRE_API(int,
         XRE_XPCShellMain, (int argc, char** argv, char** envp))
 
diff --git a/xpcom/components/ManifestParser.cpp b/xpcom/components/ManifestParser.cpp
index 95a9653..ddd09ce 100644
--- a/xpcom/components/ManifestParser.cpp
+++ b/xpcom/components/ManifestParser.cpp
@@ -35,6 +35,9 @@
 #include "nsIScriptError.h"
 #include "nsIXULAppInfo.h"
 #include "nsIXULRuntime.h"
+#ifdef MOZ_B2G_LOADER
+#include "mozilla/XPTInterfaceInfoManager.h"
+#endif
 
 using namespace mozilla;
 
@@ -63,37 +66,51 @@ struct ManifestDirective
     (nsChromeRegistry::ManifestProcessingContext& cx,
      int lineno, char *const *argv,
      bool platform, bool contentaccessible);
+#ifdef MOZ_B2G_LOADER
+  void (*xptfunc)(XPTInterfaceInfoManager::ManifestProcessingContext& cx,
+                  int lineno, char *const * argv);
+#else
+  void *xptfunc;
+#endif
 
   bool isContract;
 };
 static const ManifestDirective kParsingTable[] = {
   { "manifest",         1, false, true, true, false,
-    &nsComponentManagerImpl::ManifestManifest, nullptr },
+    &nsComponentManagerImpl::ManifestManifest, nullptr, nullptr },
   { "binary-component", 1, true, false, false, false,
-    &nsComponentManagerImpl::ManifestBinaryComponent, nullptr },
+    &nsComponentManagerImpl::ManifestBinaryComponent, nullptr, nullptr },
   { "interfaces",       1, true, false, false, false,
-    &nsComponentManagerImpl::ManifestXPT, nullptr },
+    &nsComponentManagerImpl::ManifestXPT, nullptr, nullptr },
   { "component",        2, true, false, false, false,
-    &nsComponentManagerImpl::ManifestComponent, nullptr },
+    &nsComponentManagerImpl::ManifestComponent, nullptr, nullptr },
   { "contract",         2, true, false, false, false,
-    &nsComponentManagerImpl::ManifestContract, nullptr, true},
+    &nsComponentManagerImpl::ManifestContract, nullptr, nullptr, true},
   { "category",         3, true, false, false, false,
-    &nsComponentManagerImpl::ManifestCategory, nullptr },
+    &nsComponentManagerImpl::ManifestCategory, nullptr, nullptr },
   { "content",          2, true, true, true,  true,
-    nullptr, &nsChromeRegistry::ManifestContent },
+    nullptr, &nsChromeRegistry::ManifestContent, nullptr },
   { "locale",           3, true, true, true,  false,
-    nullptr, &nsChromeRegistry::ManifestLocale },
+    nullptr, &nsChromeRegistry::ManifestLocale, nullptr },
   { "skin",             3, false, true, true,  false,
-    nullptr, &nsChromeRegistry::ManifestSkin },
+    nullptr, &nsChromeRegistry::ManifestSkin, nullptr },
   { "overlay",          2, true, true, false,  false,
-    nullptr, &nsChromeRegistry::ManifestOverlay },
+    nullptr, &nsChromeRegistry::ManifestOverlay, nullptr },
   { "style",            2, false, true, false,  false,
-    nullptr, &nsChromeRegistry::ManifestStyle },
+    nullptr, &nsChromeRegistry::ManifestStyle, nullptr },
   { "override",         2, true, true, true,  false,
-    nullptr, &nsChromeRegistry::ManifestOverride },
+    nullptr, &nsChromeRegistry::ManifestOverride, nullptr },
   { "resource",         2, true, true, false,  false,
-    nullptr, &nsChromeRegistry::ManifestResource }
+    nullptr, &nsChromeRegistry::ManifestResource, nullptr }
+};
+#ifdef MOZ_B2G_LOADER
+static const ManifestDirective kXPTParsingTable[] = {
+  { "manifest",         1, false, true, true, false,
+    nullptr, nullptr, &XPTInterfaceInfoManager::ManifestManifest },
+  { "interfaces",       1, true, false, false, false,
+    nullptr, nullptr, &XPTInterfaceInfoManager::ManifestXPT },
 };
+#endif
 
 static const char kWhitespace[] = "\t ";
 
@@ -388,10 +405,13 @@ struct CachedDirective
 
 
 void
-ParseManifest(NSLocationType type, FileLocation &file, char* buf, bool aChromeOnly)
+ParseManifest(NSLocationType type, FileLocation &file, char* buf, bool aChromeOnly, bool aXPTOnly)
 {
   nsComponentManagerImpl::ManifestProcessingContext mgrcx(type, file, aChromeOnly);
   nsChromeRegistry::ManifestProcessingContext chromecx(type, file);
+#ifdef MOZ_B2G_LOADER
+  XPTInterfaceInfoManager::ManifestProcessingContext xptcx(file);
+#endif
   nsresult rv;
 
   NS_NAMED_LITERAL_STRING(kPlatform, "platform");
@@ -511,8 +531,17 @@ ParseManifest(NSLocationType type, FileLocation &file, char* buf, bool aChromeOn
     if (!token) continue;
 
     const ManifestDirective* directive = nullptr;
-    for (const ManifestDirective* d = kParsingTable;
-	 d < ArrayEnd(kParsingTable);
+#ifdef MOZ_B2G_LOADER
+    const ManifestDirective *table =
+      !aXPTOnly ? kParsingTable : kXPTParsingTable;
+    const ManifestDirective *tableend =
+      !aXPTOnly ? ArrayEnd(kParsingTable) : ArrayEnd(kXPTParsingTable);
+#else
+    const ManifestDirective *table = kParsingTable;
+    const ManifestDirective *tablend = ArrayEnd(kParsingTable);
+#endif
+    for (const ManifestDirective* d = table;
+	 d < tableend;
 	 ++d) {
       if (!strcmp(d->directive, token)) {
 	directive = d;
@@ -634,7 +663,7 @@ ParseManifest(NSLocationType type, FileLocation &file, char* buf, bool aChromeOn
       (nsChromeRegistry::gChromeRegistry->*(directive->regfunc))
 	(chromecx, line, argv, platform, contentAccessible);
     }
-    else if (directive->ischrome || !aChromeOnly) {
+    else if (directive->mgrfunc && (directive->ischrome || !aChromeOnly)) {
       if (directive->isContract) {
         CachedDirective* cd = contracts.AppendElement();
         cd->lineno = line;
@@ -644,6 +673,13 @@ ParseManifest(NSLocationType type, FileLocation &file, char* buf, bool aChromeOn
       else
         (nsComponentManagerImpl::gComponentManager->*(directive->mgrfunc))
           (mgrcx, line, argv);
+#ifdef MOZ_B2G_LOADER
+    } else if (directive->xptfunc) {
+      directive->xptfunc(xptcx, line, argv);
+#endif /* MOZ_B2G_LOADER */
+    } else {
+      LogMessageWithContext(file, line,
+                            "No valid manifest directive.");
     }
   }
 
diff --git a/xpcom/components/ManifestParser.h b/xpcom/components/ManifestParser.h
index 2260196..4229980 100644
--- a/xpcom/components/ManifestParser.h
+++ b/xpcom/components/ManifestParser.h
@@ -13,7 +13,7 @@
 class nsIFile;
 
 void ParseManifest(NSLocationType type, mozilla::FileLocation &file,
-                   char* buf, bool aChromeOnly);
+                   char* buf, bool aChromeOnly, bool aXPTOnly=false);
 
 void LogMessage(const char* aMsg, ...);
 
diff --git a/xpcom/components/nsComponentManager.cpp b/xpcom/components/nsComponentManager.cpp
index 3516ff7..6728521 100644
--- a/xpcom/components/nsComponentManager.cpp
+++ b/xpcom/components/nsComponentManager.cpp
@@ -333,27 +333,16 @@ nsComponentManagerImpl::InitializeModuleLocations()
     sModuleLocations = new nsTArray<ComponentLocation>;
 }
 
-nsresult nsComponentManagerImpl::Init()
+static void
+AddStaticModuleLocations1(nsTArray<nsComponentManagerImpl::ComponentLocation> *aLocations)
 {
-    PR_ASSERT(NOT_INITIALIZED == mStatus);
-
-    if (nsComponentManagerLog == nullptr)
-    {
-        nsComponentManagerLog = PR_NewLogModule("nsComponentManager");
-    }
-
-    // Initialize our arena
-    PL_INIT_ARENA_POOL(&mArena, "ComponentManagerArena", NS_CM_BLOCK_SIZE);
-
     nsCOMPtr<nsIFile> greDir =
         GetLocationFromDirectoryService(NS_GRE_DIR);
     nsCOMPtr<nsIFile> appDir =
         GetLocationFromDirectoryService(NS_XPCOM_CURRENT_PROCESS_DIR);
 
-    InitializeStaticModules();
-    InitializeModuleLocations();
-
-    ComponentLocation* cl = sModuleLocations->InsertElementAt(0);
+    nsComponentManagerImpl::ComponentLocation* cl =
+        aLocations->InsertElementAt(0);
     nsCOMPtr<nsIFile> lf = CloneAndAppend(appDir, NS_LITERAL_CSTRING("chrome.manifest"));
     cl->type = NS_COMPONENT_LOCATION;
     cl->location.Init(lf);
@@ -361,11 +350,53 @@ nsresult nsComponentManagerImpl::Init()
     bool equals = false;
     appDir->Equals(greDir, &equals);
     if (!equals) {
-        cl = sModuleLocations->InsertElementAt(0);
+        cl = aLocations->InsertElementAt(0);
         cl->type = NS_COMPONENT_LOCATION;
         lf = CloneAndAppend(greDir, NS_LITERAL_CSTRING("chrome.manifest"));
         cl->location.Init(lf);
     }
+}
+
+static void
+AddStaticModuleLocations2(nsTArray<nsComponentManagerImpl::ComponentLocation> *aLocations)
+{
+    nsCOMPtr<nsIFile> greDir =
+        GetLocationFromDirectoryService(NS_GRE_DIR);
+    nsCOMPtr<nsIFile> appDir =
+        GetLocationFromDirectoryService(NS_XPCOM_CURRENT_PROCESS_DIR);
+
+    nsComponentManagerImpl::ComponentLocation* cl;
+
+    nsRefPtr<nsZipArchive> appOmnijar = mozilla::Omnijar::GetReader(mozilla::Omnijar::APP);
+    if (appOmnijar) {
+        cl = aLocations->InsertElementAt(1); // Insert after greDir
+        cl->type = NS_COMPONENT_LOCATION;
+        cl->location.Init(appOmnijar, "chrome.manifest");
+    }
+    nsRefPtr<nsZipArchive> greOmnijar = mozilla::Omnijar::GetReader(mozilla::Omnijar::GRE);
+    if (greOmnijar) {
+        cl = aLocations->InsertElementAt(0);
+        cl->type = NS_COMPONENT_LOCATION;
+        cl->location.Init(greOmnijar, "chrome.manifest");
+    }
+}
+
+nsresult nsComponentManagerImpl::Init()
+{
+    PR_ASSERT(NOT_INITIALIZED == mStatus);
+
+    if (nsComponentManagerLog == nullptr)
+    {
+        nsComponentManagerLog = PR_NewLogModule("nsComponentManager");
+    }
+
+    // Initialize our arena
+    PL_INIT_ARENA_POOL(&mArena, "ComponentManagerArena", NS_CM_BLOCK_SIZE);
+
+    InitializeStaticModules();
+    InitializeModuleLocations();
+
+    AddStaticModuleLocations1(sModuleLocations);
 
     PR_LOG(nsComponentManagerLog, PR_LOG_DEBUG,
            ("nsComponentManager: Initialized."));
@@ -381,18 +412,7 @@ nsresult nsComponentManagerImpl::Init()
     for (uint32_t i = 0; i < sStaticModules->Length(); ++i)
         RegisterModule((*sStaticModules)[i], nullptr);
 
-    nsRefPtr<nsZipArchive> appOmnijar = mozilla::Omnijar::GetReader(mozilla::Omnijar::APP);
-    if (appOmnijar) {
-        cl = sModuleLocations->InsertElementAt(1); // Insert after greDir
-        cl->type = NS_COMPONENT_LOCATION;
-        cl->location.Init(appOmnijar, "chrome.manifest");
-    }
-    nsRefPtr<nsZipArchive> greOmnijar = mozilla::Omnijar::GetReader(mozilla::Omnijar::GRE);
-    if (greOmnijar) {
-        cl = sModuleLocations->InsertElementAt(0);
-        cl->type = NS_COMPONENT_LOCATION;
-        cl->location.Init(greOmnijar, "chrome.manifest");
-    }
+    AddStaticModuleLocations2(sModuleLocations);
 
     RereadChromeManifests(false);
 
@@ -524,10 +544,11 @@ CutExtension(nsCString& path)
         path.Cut(0, dotPos + 1);
 }
 
-void
-nsComponentManagerImpl::RegisterManifest(NSLocationType aType,
-                                         FileLocation &aFile,
-                                         bool aChromeOnly)
+static void
+DoRegisterManifest(NSLocationType aType,
+                   FileLocation &aFile,
+                   bool aChromeOnly,
+                   bool aXPTOnly)
 {
     uint32_t len;
     FileLocation::Data data;
@@ -542,7 +563,7 @@ nsComponentManagerImpl::RegisterManifest(NSLocationType aType,
     }
     if (NS_SUCCEEDED(rv)) {
         buf[len] = '\0';
-        ParseManifest(aType, aFile, buf, aChromeOnly);
+        ParseManifest(aType, aFile, buf, aChromeOnly, aXPTOnly);
     } else if (NS_BOOTSTRAPPED_LOCATION != aType) {
         nsCString uri;
         aFile.GetURIString(uri);
@@ -551,6 +572,14 @@ nsComponentManagerImpl::RegisterManifest(NSLocationType aType,
 }
 
 void
+nsComponentManagerImpl::RegisterManifest(NSLocationType aType,
+                                         FileLocation &aFile,
+                                         bool aChromeOnly)
+{
+    DoRegisterManifest(aType, aFile, aChromeOnly, false);
+}
+
+void
 nsComponentManagerImpl::ManifestManifest(ManifestProcessingContext& cx, int lineno, char *const * argv)
 {
     char* file = argv[0];
@@ -1936,6 +1965,82 @@ nsComponentManagerImpl::GetManifestLocations(nsIArray **aLocations)
   return NS_OK;
 }
 
+#ifdef MOZ_B2G_LOADER
+
+/* static */
+void
+XPTInterfaceInfoManager::ManifestManifest(ManifestProcessingContext &aCx,
+                                          int aLineno,
+                                          char * const * aArgv)
+{
+  char* file = aArgv[0];
+  FileLocation f(aCx.mFile, file);
+  uint32_t len;
+  FileLocation::Data data;
+  nsAutoArrayPtr<char> buf;
+  nsresult rv = f.GetData(data);
+  if (NS_SUCCEEDED(rv)) {
+    rv = data.GetSize(&len);
+  }
+  if (NS_SUCCEEDED(rv)) {
+    buf = new char[len + 1];
+    rv = data.Copy(buf, len);
+  }
+  if (NS_SUCCEEDED(rv)) {
+    buf[len] = '\0';
+    ParseManifest(NS_COMPONENT_LOCATION, f, buf, false, true);
+  } else {
+    nsCString uri;
+    f.GetURIString(uri);
+    LogMessage("Could not read chrome manifest '%s'.", uri.get());
+  }
+}
+
+/* static */
+void
+XPTInterfaceInfoManager::ManifestXPT(ManifestProcessingContext &aCx,
+                                     int aLineno,
+                                     char * const * aArgv)
+{
+  FileLocation f(aCx.mFile, aArgv[0]);
+  uint32_t len;
+  FileLocation::Data data;
+  nsAutoArrayPtr<char> buf;
+  nsresult rv = f.GetData(data);
+  if (NS_SUCCEEDED(rv)) {
+    rv = data.GetSize(&len);
+  }
+  if (NS_SUCCEEDED(rv)) {
+    buf = new char[len];
+    rv = data.Copy(buf, len);
+  }
+  if (NS_SUCCEEDED(rv)) {
+    GetSingleton()->RegisterBuffer(buf, len);
+  } else {
+    nsCString uri;
+    f.GetURIString(uri);
+    LogMessage("Could not read '%s'.", uri.get());
+  }
+}
+
+/* static */
+void
+nsComponentManagerImpl::PreloadXPT()
+{
+    nsTArray<ComponentLocation> *locations = new nsTArray<ComponentLocation>;
+    AddStaticModuleLocations1(locations);
+    AddStaticModuleLocations2(locations);
+
+    for (uint32_t i = 0; i < locations->Length(); ++i) {
+        ComponentLocation& l = locations->ElementAt(i);
+        DoRegisterManifest(l.type, l.location, false, true);
+    }
+
+    delete locations;
+}
+
+#endif /* MOZ_B2G_LOADER */
+
 EXPORT_XPCOM_API(nsresult)
 XRE_AddManifestLocation(NSLocationType aType, nsIFile* aLocation)
 {
diff --git a/xpcom/components/nsComponentManager.h b/xpcom/components/nsComponentManager.h
index 1052de0..39710c0 100644
--- a/xpcom/components/nsComponentManager.h
+++ b/xpcom/components/nsComponentManager.h
@@ -316,6 +316,10 @@ public:
     int64_t Amount() MOZ_OVERRIDE;
     size_t SizeOfIncludingThis(mozilla::MallocSizeOf aMallocSizeOf);
 
+#ifdef MOZ_B2G_LOADER
+    static void PreloadXPT();
+#endif
+
 private:
     ~nsComponentManagerImpl();
 };
diff --git a/xpcom/reflect/xptinfo/public/XPTInterfaceInfoManager.h b/xpcom/reflect/xptinfo/public/XPTInterfaceInfoManager.h
index a02103b..b87084c 100644
--- a/xpcom/reflect/xptinfo/public/XPTInterfaceInfoManager.h
+++ b/xpcom/reflect/xptinfo/public/XPTInterfaceInfoManager.h
@@ -15,6 +15,10 @@
 #include "mozilla/ReentrantMonitor.h"
 #include "nsDataHashtable.h"
 
+#ifdef MOZ_B2G_LOADER
+#include "mozilla/FileLocation.h"
+#endif
+
 template<typename T> class nsCOMArray;
 class nsIMemoryReporter;
 class XPTHeader;
@@ -33,6 +37,23 @@ class XPTInterfaceInfoManager MOZ_FINAL
     NS_DECL_NSIINTERFACEINFOMANAGER
 
 public:
+#ifdef MOZ_B2G_LOADER
+    struct ManifestProcessingContext
+    {
+        ManifestProcessingContext(FileLocation &aFile)
+            : mFile(aFile)
+        { }
+
+        ~ManifestProcessingContext() { }
+
+        FileLocation mFile;
+    };
+    static void ManifestManifest(ManifestProcessingContext& aCx,
+                                 int aLineno, char * const *aArgv);
+    static void ManifestXPT(ManifestProcessingContext& aCx,
+                            int aLineno, char * const *aArgv);
+#endif
+
     // GetSingleton() is infallible
     static XPTInterfaceInfoManager* GetSingleton();
     static void FreeInterfaceInfoManager();
diff --git a/xpcom/threads/BackgroundHangMonitor.cpp b/xpcom/threads/BackgroundHangMonitor.cpp
index 87c8477a..faac117 100644
--- a/xpcom/threads/BackgroundHangMonitor.cpp
+++ b/xpcom/threads/BackgroundHangMonitor.cpp
@@ -63,6 +63,7 @@ private:
 
 public:
   static StaticRefPtr<BackgroundHangManager> sInstance;
+  static bool sProhibited;
 
   // Lock for access to members of this class
   Monitor mLock;
@@ -160,6 +161,7 @@ public:
 
 
 StaticRefPtr<BackgroundHangManager> BackgroundHangManager::sInstance;
+bool BackgroundHangManager::sProhibited = false;
 
 ThreadLocal<BackgroundHangThread*> BackgroundHangThread::sTlsKey;
 
@@ -409,6 +411,12 @@ BackgroundHangThread*
 BackgroundHangThread::FindThread()
 {
 #ifdef MOZ_ENABLE_BACKGROUND_HANG_MONITOR
+  if (BackgroundHangManager::sInstance == nullptr) {
+    MOZ_ASSERT(BackgroundHangManager::sProhibited,
+               "BackbroundHandleManager is not initialized");
+    return nullptr;
+  }
+
   if (sTlsKey.initialized()) {
     // Use TLS if available
     return sTlsKey.get();
@@ -436,6 +444,7 @@ void
 BackgroundHangMonitor::Startup()
 {
 #ifdef MOZ_ENABLE_BACKGROUND_HANG_MONITOR
+  MOZ_ASSERT(!BackgroundHangManager::sProhibited, "Prohibited");
   MOZ_ASSERT(!BackgroundHangManager::sInstance, "Already initialized");
   ThreadStackHelper::Startup();
   BackgroundHangThread::Startup();
@@ -447,6 +456,7 @@ void
 BackgroundHangMonitor::Shutdown()
 {
 #ifdef MOZ_ENABLE_BACKGROUND_HANG_MONITOR
+  MOZ_ASSERT(!BackgroundHangManager::sProhibited, "Prohibited");
   MOZ_ASSERT(BackgroundHangManager::sInstance, "Not initialized");
   /* Scope our lock inside Shutdown() because the sInstance object can
      be destroyed as soon as we set sInstance to nullptr below, and
@@ -463,7 +473,7 @@ BackgroundHangMonitor::BackgroundHangMonitor(const char* aName,
   : mThread(BackgroundHangThread::FindThread())
 {
 #ifdef MOZ_ENABLE_BACKGROUND_HANG_MONITOR
-  if (!mThread) {
+  if (!BackgroundHangManager::sProhibited && !mThread) {
     mThread = new BackgroundHangThread(aName, aTimeoutMs, aMaxTimeoutMs);
   }
 #endif
@@ -473,7 +483,8 @@ BackgroundHangMonitor::BackgroundHangMonitor()
   : mThread(BackgroundHangThread::FindThread())
 {
 #ifdef MOZ_ENABLE_BACKGROUND_HANG_MONITOR
-  MOZ_ASSERT(mThread, "Thread not initialized for hang monitoring");
+  MOZ_ASSERT(!BackgroundHangManager::sProhibited || mThread,
+             "Thread not initialized for hang monitoring");
 #endif
 }
 
@@ -485,6 +496,9 @@ void
 BackgroundHangMonitor::NotifyActivity()
 {
 #ifdef MOZ_ENABLE_BACKGROUND_HANG_MONITOR
+  if (mThread == nullptr) {
+    return;
+  }
   mThread->NotifyActivity();
 #endif
 }
@@ -493,18 +507,47 @@ void
 BackgroundHangMonitor::NotifyWait()
 {
 #ifdef MOZ_ENABLE_BACKGROUND_HANG_MONITOR
+  if (mThread == nullptr) {
+    return;
+  }
   mThread->NotifyWait();
 #endif
 }
 
+void
+BackgroundHangMonitor::Prohibit()
+{
+#ifdef MOZ_ENABLE_BACKGROUND_HANG_MONITOR
+  MOZ_ASSERT(BackgroundHangManager::sInstance == nullptr,
+             "Prohibit after calling Startup()");
+  BackgroundHangManager::sProhibited = true;
+#endif
+}
+
+void
+BackgroundHangMonitor::Allow()
+{
+#ifdef MOZ_ENABLE_BACKGROUND_HANG_MONITOR
+  MOZ_ASSERT(BackgroundHangManager::sInstance == nullptr,
+             "Allow after calling Startup()");
+  BackgroundHangManager::sProhibited = false;
+#endif
+}
+
 
 /* Because we are iterating through the BackgroundHangThread linked list,
    we need to take a lock. Using MonitorAutoLock as a base class makes
    sure all of that is taken care of for us. */
 BackgroundHangMonitor::ThreadHangStatsIterator::ThreadHangStatsIterator()
   : MonitorAutoLock(BackgroundHangManager::sInstance->mLock)
-  , mThread(BackgroundHangManager::sInstance->mHangThreads.getFirst())
+  , mThread(BackgroundHangManager::sInstance ?
+            BackgroundHangManager::sInstance->mHangThreads.getFirst() :
+            nullptr)
 {
+#ifdef MOZ_ENABLE_BACKGROUND_HANG_MONITOR
+  MOZ_ASSERT(BackgroundHangManager::sInstance || BackgroundHangManager::sProhibited,
+             "Inconsistent state");
+#endif
 }
 
 Telemetry::ThreadHangStats*
diff --git a/xpcom/threads/BackgroundHangMonitor.h b/xpcom/threads/BackgroundHangMonitor.h
index 776ead1..4a78741 100644
--- a/xpcom/threads/BackgroundHangMonitor.h
+++ b/xpcom/threads/BackgroundHangMonitor.h
@@ -201,6 +201,19 @@ public:
    * NotifyActivity when subsequently exiting the wait state.
    */
   void NotifyWait();
+
+  /**
+   * Prohibit the hang monitor from active.
+   * Startup() should not be called after calling this method.
+   */
+  static void Prohibit();
+
+  /**
+   * Allow the hang monitor to be ran. (The inversion of Prohibit()).
+   * You could call Startup() after calling this method.
+   * The hang monitor is allowed to run by default.
+   */
+  static void Allow();
 };
 
 } // namespace mozilla
-- 
1.7.9.5

