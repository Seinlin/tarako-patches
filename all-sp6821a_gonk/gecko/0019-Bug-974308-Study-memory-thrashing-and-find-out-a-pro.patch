From 4ff6db571365982160ab3aa76d5bbf2b91bd1161 Mon Sep 17 00:00:00 2001
From: dannyliang <dliang@mozilla.com>
Date: Tue, 25 Feb 2014 17:25:22 +0800
Subject: [PATCH] Bug 974308 - Study memory thrashing and find out a proper
 way to handle it

---
 b2g/app/b2g.js                     |    1 +
 dom/ipc/ContentParent.cpp          |    4 ++--
 dom/ipc/ProcessPriorityManager.cpp |   45 +++++++++++++++++++++++++++++++++++-
 3 files changed, 47 insertions(+), 3 deletions(-)

diff --git a/b2g/app/b2g.js b/b2g/app/b2g.js
index 382afef..1e4fac6 100644
--- a/b2g/app/b2g.js
+++ b/b2g/app/b2g.js
@@ -616,6 +616,7 @@ pref("dom.ipc.processPriorityManager.enabled", true);
 pref("dom.ipc.processPriorityManager.backgroundGracePeriodMS", 1000);
 pref("dom.ipc.processPriorityManager.backgroundPerceivableGracePeriodMS", 5000);
 pref("dom.ipc.processPriorityManager.temporaryPriorityLockMS", 5000);
+pref("dom.ipc.processPriorityManager.killBackgroundApps", true);
 
 // Number of different background levels for background processes.  We use
 // these different levels to force the low-memory killer to kill processes in
diff --git a/dom/ipc/ContentParent.cpp b/dom/ipc/ContentParent.cpp
index ad0edfd..2e2e014 100644
--- a/dom/ipc/ContentParent.cpp
+++ b/dom/ipc/ContentParent.cpp
@@ -318,8 +318,8 @@ ContentParent::MaybeTakePreallocatedAppProcess(const nsAString& aAppManifestURL,
         return nullptr;
     }
 
-    if (!process->SetPriorityAndCheckIsAlive(aInitialPriority) ||
-        !process->TransformPreallocatedIntoApp(aAppManifestURL, aPrivs)) {
+    if (!process->TransformPreallocatedIntoApp(aAppManifestURL, aPrivs) ||
+        !process->SetPriorityAndCheckIsAlive(aInitialPriority)) {
         // Kill the process just in case it's not actually dead; we don't want
         // to "leak" this process!
         process->KillHard();
diff --git a/dom/ipc/ProcessPriorityManager.cpp b/dom/ipc/ProcessPriorityManager.cpp
index 0078ed3..be497aa 100644
--- a/dom/ipc/ProcessPriorityManager.cpp
+++ b/dom/ipc/ProcessPriorityManager.cpp
@@ -43,7 +43,7 @@
 //
 // (Wow, our logging story is a huge mess.)
 
-// #define ENABLE_LOGGING 1
+#define ENABLE_LOGGING 1
 
 #if defined(ANDROID) && defined(ENABLE_LOGGING)
 #  include <android/log.h>
@@ -312,6 +312,11 @@ public:
    */
   void AddIntoBackgroundLRUPool(ContentParent* aContentParent);
 
+  /**
+    * Kill all the background apps except the one with the aDontKill pid.
+    */
+  void KillBackgroundApps(pid_t aDontKill);
+
 private:
   static StaticAutoPtr<BackgroundProcessLRUPool> sSingleton;
 
@@ -1045,6 +1050,20 @@ ParticularProcessPriorityManager::SetPriorityNow(ProcessPriority aPriority,
     ProcessPriorityManagerImpl::GetSingleton()->
       NotifyProcessPriorityChanged(this, oldPriority);
   }
+
+  if (IsPreallocated() ||
+      mPriority != PROCESS_PRIORITY_FOREGROUND ||
+      !Preferences::GetBool(
+        "dom.ipc.processPriorityManager.killBackgroundApps")) {
+    return;
+  }
+
+  // Kill background apps if any are killable.
+  BackgroundProcessLRUPool* singleton =
+    BackgroundProcessLRUPool::Singleton();
+  if (singleton) {
+    singleton->KillBackgroundApps(Pid());
+  }
 }
 
 void
@@ -1282,6 +1301,30 @@ BackgroundProcessLRUPool::RemoveFromBackgroundLRUPool(
   }
 }
 
+void
+BackgroundProcessLRUPool::KillBackgroundApps(pid_t aDontKill)
+{
+  nsTArray<ContentParent*> killed;
+
+  LOG("KillBackgroundApps");
+
+  // Gather content parents we need to kill.
+  for (int32_t i = 0; i < mLRUPoolSize; i++) {
+    ContentParent* parent = mLRUPool[i];
+    if (parent && parent->Pid() != aDontKill) {
+      killed.AppendElement(parent);
+    }
+  }
+
+  // Kill them and clean up the LRU pool.
+  for (uint32_t i = 0; i < killed.Length(); i++) {
+    ContentParent* parent = killed[i];
+    LOG("About to force kill pid: %d", parent->Pid());
+    RemoveFromBackgroundLRUPool(parent);
+    unused << kill(parent->Pid(), SIGKILL);
+  }
+}
+
 nsresult
 BackgroundProcessLRUPool::UpdateAvailableIndexInLRUPool(
     ContentParent* aContentParent,
-- 
1.7.9.5

