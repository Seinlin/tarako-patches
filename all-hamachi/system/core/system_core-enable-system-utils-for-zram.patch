From acd1114cd6c76f81147ef0d1b32c0d53e342e1b0 Mon Sep 17 00:00:00 2001
From: Kai-Zhen Li <kli@mozilla.com>
Date: Mon, 16 Dec 2013 11:50:39 +0800
Subject: [PATCH] enable system utils for zram.

---
 toolbox/Android.mk |    6 +-
 toolbox/mknod.c    |  220 +++++++++++++++++++++++
 toolbox/mkswap.c   |  494 ++++++++++++++++++++++++++++++++++++++++++++++++++++
 toolbox/swapoff.c  |  152 ++++++++++++++++
 toolbox/swapon.c   |  152 ++++++++++++++++
 5 files changed, 1023 insertions(+), 1 deletion(-)
 create mode 100644 toolbox/mknod.c
 create mode 100644 toolbox/mkswap.c
 create mode 100644 toolbox/swapoff.c
 create mode 100644 toolbox/swapon.c

diff --git a/toolbox/Android.mk b/toolbox/Android.mk
index d7a675a..33c72cd 100644
--- a/toolbox/Android.mk
+++ b/toolbox/Android.mk
@@ -55,7 +55,11 @@ TOOLS := \
 	nandread \
 	ionice \
 	touch \
-	lsof
+	lsof \
+	mkswap \
+	swapon \
+	swapoff \
+	mknod
 
 ifneq (,$(filter userdebug eng,$(TARGET_BUILD_VARIANT)))
 TOOLS += r
diff --git a/toolbox/mknod.c b/toolbox/mknod.c
new file mode 100644
index 0000000..c3cf5e1
--- /dev/null
+++ b/toolbox/mknod.c
@@ -0,0 +1,220 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Mini mknod implementation for busybox
+ *
+ * Copyright (C) 1995, 1996 by Bruce Perens <bruce@pixar.com>.
+ * Copyright (C) 1999-2002 by Erik Andersen <andersee@debian.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#if 1
+#include <stdio.h>
+#include <errno.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdlib.h>
+#include <sys/types.h>
+#include <stdarg.h>
+#include <sys/stat.h>
+//#include "busybox.h"
+
+static void usage(char *prog)
+{
+	fprintf(stderr, 
+		"Usage: mknod [OPTIONS] NAME TYPE MAJOR MINOR\n\n"
+
+"Create a special file (block, character, or pipe)\n\n"
+
+"Options:\n"
+"        -m      Create the special file using the specified mode\n"
+"TYPEs include:\n"
+"        b:      Make a block device\n"
+"        c or u: Make a character device\n"
+"        p:      Make a named pipe (MAJOR and MINOR are ignored)\n");
+}
+#define show_usage() usage(argv[0])
+
+
+extern void perror_msg_and_die(const char *s, ...);
+extern const char *applet_name;
+
+
+static int parse_mode(const char *s, mode_t * theMode)
+{
+	static const mode_t group_set[] = { 
+		S_ISUID | S_IRWXU,		/* u */
+		S_ISGID | S_IRWXG,		/* g */
+		S_IRWXO,				/* o */
+		S_ISUID | S_ISGID | S_ISVTX | S_IRWXU | S_IRWXG | S_IRWXO /* a */
+	};
+
+	static const mode_t mode_set[] = {
+		S_IRUSR | S_IRGRP | S_IROTH, /* r */
+		S_IWUSR | S_IWGRP | S_IWOTH, /* w */
+		S_IXUSR | S_IXGRP | S_IXOTH, /* x */
+		S_ISUID | S_ISGID,		/* s */
+		S_ISVTX					/* t */
+	};
+
+	static const char group_chars[] = "ugoa";
+	static const char mode_chars[] = "rwxst";
+
+	const char *p;
+
+	mode_t andMode =
+		S_ISVTX | S_ISUID | S_ISGID | S_IRWXU | S_IRWXG | S_IRWXO;
+	mode_t orMode = 0;
+	mode_t mode;
+	mode_t groups;
+	char type;
+	char c;
+
+	if (s==NULL) {
+		return 0;
+	}
+
+	do {
+		mode = 0;
+		groups = 0;
+	NEXT_GROUP:
+		if ((c = *s++) == '\0') {
+			return -1;
+		}
+		for (p=group_chars ; *p ; p++) {
+			if (*p == c) {
+				groups |= group_set[(int)(p-group_chars)];
+				goto NEXT_GROUP;
+			}
+		}
+		switch (c) {
+			case '=':
+			case '+':
+			case '-':
+				type = c;
+				if (groups == 0) { /* The default is "all" */
+					groups |= S_ISUID | S_ISGID | S_ISVTX
+							| S_IRWXU | S_IRWXG | S_IRWXO;
+				}
+				break;
+			default:
+				if ((c < '0') || (c > '7') || (mode | groups)) {
+					return 0;
+				} else {
+					*theMode = strtol(--s, NULL, 8);
+					return 1;
+				}
+		}
+
+	NEXT_MODE:
+		if (((c = *s++) != '\0') && (c != ',')) {
+			for (p=mode_chars ; *p ; p++) {
+				if (*p == c) {
+					mode |= mode_set[(int)(p-mode_chars)];
+					goto NEXT_MODE;
+				}
+			}
+			break;				/* We're done so break out of loop.*/
+		}
+		switch (type) {
+			case '=':
+				andMode &= ~(groups); /* Now fall through. */
+			case '+':
+				orMode |= mode & groups;
+				break;
+			case '-':
+				andMode &= ~(mode & groups);
+				orMode &= ~(mode & groups);
+				break;
+		}
+	} while (c == ',');
+
+	*theMode &= andMode;
+	*theMode |= orMode;
+
+	return 1;
+}
+
+int mknod_main(int argc, char **argv)
+{
+	char *thisarg;
+	mode_t mode = 0;
+	mode_t perm = 0666;
+	dev_t dev = 0;
+
+	argc--;
+	argv++;
+	
+	applet_name = "mknod";
+
+	/* Parse any options */
+	while (argc > 1) {
+		if (**argv != '-')
+			break;
+		thisarg = *argv;
+		thisarg++;
+		switch (*thisarg) {
+		case 'm':
+			argc--;
+			argv++;
+			parse_mode(*argv, &perm);
+			umask(0);
+			break;
+		default:
+			show_usage();
+			return EXIT_FAILURE;
+		}
+		argc--;
+		argv++;
+	}
+	if (argc != 4 && argc != 2) {
+		show_usage();
+		return EXIT_FAILURE;
+	}
+	switch (argv[1][0]) {
+	case 'c':
+	case 'u':
+		mode = S_IFCHR;
+		break;
+	case 'b':
+		mode = S_IFBLK;
+		break;
+	case 'p':
+		mode = S_IFIFO;
+		if (argc!=2) {
+			show_usage();
+			return EXIT_FAILURE;
+		}
+		break;
+	default:
+		show_usage();
+		return EXIT_FAILURE;
+	}
+
+	if (mode == S_IFCHR || mode == S_IFBLK) {
+		dev = (atoi(argv[2]) << 8) | atoi(argv[3]);
+	}
+
+	mode |= perm;
+
+	if (mknod(argv[0], mode, dev) != 0)
+		perror_msg_and_die("%s", argv[0]);
+	return EXIT_SUCCESS;
+}
+#endif
+
+
diff --git a/toolbox/mkswap.c b/toolbox/mkswap.c
new file mode 100644
index 0000000..0954da8
--- /dev/null
+++ b/toolbox/mkswap.c
@@ -0,0 +1,494 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * mkswap.c - set up a linux swap device
+ *
+ * (C) 1991 Linus Torvalds. This file may be redistributed as per
+ * the Linux copyright.
+ */
+/*
+ * 20.12.91  -  time began. Got VM working yesterday by doing this by hand.
+ *
+ * Usage: mkswap [-c] [-vN] [-f] device [size-in-blocks]
+ *
+ *      -c   for readability checking. (Use it unless you are SURE!)
+ *      -vN  for swap areas version N. (Only N=0,1 known today.)
+ *      -f   for forcing swap creation even if it would smash partition table.
+ *
+ * The device may be a block device or an image of one, but this isn't
+ * enforced (but it's not much fun on a character device :-).
+ *
+ * Patches from jaggy@purplet.demon.co.uk (Mike Jagdis) to make the
+ * size-in-blocks parameter optional added Wed Feb  8 10:33:43 1995.
+ *
+ * Version 1 swap area code (for kernel 2.1.117), aeb, 981010.
+ *
+ * Sparc fixes, jj@ultra.linux.cz (Jakub Jelinek), 981201 - mangled by aeb.
+ * V1_MAX_PAGES fixes, jj, 990325.
+ *
+ * 1999-02-22 Arkadiusz Mi?kiewicz <misiek@misiek.eu.org>
+ * - added Native Language Support
+ *
+ *  from util-linux -- adapted for busybox by
+ *  Erik Andersen <andersee@debian.org>. I ripped out Native Language
+ *  Support, made some stuff smaller, and fitted for life in busybox.
+ *
+ */
+#include <stdio.h>
+#include <unistd.h>
+#include <string.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <stdarg.h>
+#include <sys/ioctl.h>                  /* for _IO */
+#include <sys/utsname.h>
+#include <asm/page.h>                   /* for PAGE_SIZE and PAGE_SHIFT */
+                                /* we also get PAGE_SIZE via getpagesize() */
+//#include "busybox.h"
+#include <sys/stat.h>
+
+//#define printf error_msg
+
+#ifndef _IO
+/* pre-1.3.45 */
+static const int BLKGETSIZE = 0x1260;
+#else
+/* same on i386, m68k, arm; different on alpha, mips, sparc, ppc */
+#define BLKGETSIZE _IO(0x12,96)
+#endif
+static char *device_name = NULL;
+static int DEV = -1;
+static long PAGES = 0;
+static int check = 0;
+static int badpages = 0;
+static int version = -1;
+#define MAKE_VERSION(p,q,r)     (65536*(p) + 256*(q) + (r))
+/*
+ * The definition of the union swap_header uses the constant PAGE_SIZE.
+ * Unfortunately, on some architectures this depends on the hardware model,
+ * and can only be found at run time -- we use getpagesize().
+ */
+static int pagesize;
+static int *signature_page;
+
+static struct swap_header_v1 {
+        char bootbits[1024];            /* Space for disklabel etc. */
+        unsigned int version;
+        unsigned int last_page;
+        unsigned int nr_badpages;
+        unsigned int padding[125];
+        unsigned int badpages[1];
+} *p;
+
+
+
+static void *xmalloc(size_t size)
+{
+	void *p = NULL;
+
+	if (!(p = malloc(size))) {
+	    printf("ERROR : memory not allocated\n");
+	    exit(0);
+	}
+	return p;
+}
+
+const char *applet_name;
+
+
+static void usage(char *prog)
+{
+	fprintf(stderr, 
+		"Usage: %s [-c] [-pPAGESZ] [-L label] [-U UUID] /dev/name [blocks]\n",
+		prog);
+}
+#define show_usage() usage(argv[0])
+
+void verror_msg(const char *s, va_list p)
+{
+	fflush(stdout);
+	fprintf(stderr, "%s: ", applet_name);
+	vfprintf(stderr, s, p);
+}
+
+void error_msg_and_die(const char *s, ...)
+{
+	va_list p;
+
+	va_start(p, s);
+	verror_msg(s, p);
+	va_end(p);
+	putc('\n', stderr);
+	exit(EXIT_FAILURE);
+}
+
+void vperror_msg(const char *s, va_list p)
+{
+	int err=errno;
+	if(s == 0) s = "";
+	verror_msg(s, p);
+	if (*s) s = ": ";
+	fprintf(stderr, "%s%s\n", s, strerror(err));
+}
+
+void perror_msg(const char *s, ...)
+{
+	va_list p;
+
+	va_start(p, s);
+	vperror_msg(s, p);
+	va_end(p);
+}
+
+static int get_kernel_revision(void)
+{
+	struct utsname name;
+	char *s;
+	int i, r;
+
+	if (uname(&name) == -1) {
+		perror_msg("cannot get system information");
+		return (0);
+	}
+
+	s = name.release;
+	r = 0;
+	for (i=0 ; i<3 ; i++) {
+		r = r * 256 + atoi(strtok(s, "."));
+		s = NULL;
+	}
+	return r;
+}
+
+void error_msg(const char *s, ...)
+{
+	va_list p;
+
+	va_start(p, s);
+	verror_msg(s, p);
+	va_end(p);
+	putc('\n', stderr);
+}
+
+void perror_msg_and_die(const char *s, ...)
+{
+	va_list p;
+
+	va_start(p, s);
+	vperror_msg(s, p);
+	va_end(p);
+	exit(EXIT_FAILURE);
+}
+
+static void init_signature_page()
+{
+        pagesize = getpagesize();
+#ifdef PAGE_SIZE
+	if (pagesize != PAGE_SIZE)
+		error_msg("Assuming pages of size %d", pagesize);
+#endif
+        signature_page = (int *) xmalloc(pagesize);
+        memset(signature_page, 0, pagesize);
+        p = (struct swap_header_v1 *) signature_page;
+}
+static void write_signature(char *sig)
+{
+        char *sp = (char *) signature_page;
+        strncpy(sp + pagesize - 10, sig, 10);
+}
+#define V0_MAX_PAGES    (8 * (pagesize - 10))
+/* Before 2.2.0pre9 */
+#define V1_OLD_MAX_PAGES        ((0x7fffffff / pagesize) - 1)
+/* Since 2.2.0pre9:
+   error if nr of pages >= SWP_OFFSET(SWP_ENTRY(0,~0UL))
+   with variations on
+        #define SWP_ENTRY(type,offset) (((type) << 1) | ((offset) << 8))
+        #define SWP_OFFSET(entry) ((entry) >> 8)
+   on the various architectures. Below the result - yuk.
+   Machine      pagesize        SWP_ENTRY       SWP_OFFSET      bound+1 oldbound+2
+   i386         2^12            o<<8            e>>8            1<<24   1<<19
+   mips         2^12            o<<15           e>>15           1<<17   1<<19
+   alpha        2^13            o<<40           e>>40           1<<24   1<<18
+   m68k         2^12            o<<12           e>>12           1<<20   1<<19
+   sparc        2^{12,13}       (o&0x3ffff)<<9  (e>>9)&0x3ffff  1<<18   1<<{19,18}
+   sparc64      2^13            o<<13           e>>13           1<<51   1<<18
+   ppc          2^12            o<<8            e>>8            1<<24   1<<19
+   armo         2^{13,14,15}    o<<8            e>>8            1<<24   1<<{18,17,16}
+   armv         2^12            o<<9            e>>9            1<<23   1<<19
+   assuming that longs have 64 bits on alpha and sparc64 and 32 bits elsewhere.
+   The bad part is that we need to know this since the kernel will
+   refuse a swap space if it is too large.
+*/
+/* patch from jj - why does this differ from the above? */
+#if defined(__alpha__)
+#define V1_MAX_PAGES           ((1 << 24) - 1)
+#elif defined(__mips__)
+#define V1_MAX_PAGES           ((1 << 17) - 1)
+#elif defined(__sparc_v9__)
+#define V1_MAX_PAGES           ((3 << 29) - 1)
+#elif defined(__sparc__)
+#define V1_MAX_PAGES           (pagesize == 8192 ? ((3 << 29) - 1) : ((1 << 18) - 1))
+#else
+#define V1_MAX_PAGES           V1_OLD_MAX_PAGES
+#endif
+/* man page now says:
+The maximum useful size of a swap area now depends on the architecture.
+It is roughly 2GB on i386, PPC, m68k, ARM, 1GB on sparc, 512MB on mips,
+128GB on alpha and 3TB on sparc64.
+*/
+#define MAX_BADPAGES    ((pagesize-1024-128*sizeof(int)-10)/sizeof(int))
+static void bit_set(unsigned int *addr, unsigned int nr)
+{
+        unsigned int r, m;
+        addr += nr / (8 * sizeof(int));
+        r = *addr;
+        m = 1 << (nr & (8 * sizeof(int) - 1));
+        *addr = r | m;
+}
+static int bit_test_and_clear(unsigned int *addr, unsigned int nr)
+{
+        unsigned int r, m;
+        addr += nr / (8 * sizeof(int));
+        r = *addr;
+        m = 1 << (nr & (8 * sizeof(int) - 1));
+        *addr = r & ~m;
+        return (r & m) != 0;
+}
+
+static void page_ok(int page)
+{
+        if (version == 0)
+                bit_set(signature_page, page);
+}
+static void page_bad(int page)
+{
+        if (version == 0)
+		bit_test_and_clear(signature_page, page);
+	else {
+		if (badpages == MAX_BADPAGES)
+			error_msg_and_die("too many bad pages");
+		p->badpages[badpages] = page;
+	}
+	badpages++;
+}
+static void check_blocks(void)
+{
+        unsigned int current_page;
+        int do_seek = 1;
+        char *buffer;
+        buffer = xmalloc(pagesize);
+        current_page = 0;
+        while (current_page < PAGES) {
+                if (!check) {
+			page_ok(current_page++);
+			continue;
+		}
+		if (do_seek && lseek(DEV, current_page * pagesize, SEEK_SET) !=
+			current_page * pagesize)
+			error_msg_and_die("seek failed in check_blocks");
+		if ((do_seek = (pagesize != read(DEV, buffer, pagesize)))) {
+			page_bad(current_page++);
+			continue;
+		}
+		page_ok(current_page++);
+	}
+	if (badpages == 1)
+		printf("one bad page\n");
+	else if (badpages > 1)
+		printf("%d bad pages\n", badpages);
+}
+
+static long valid_offset(int fd, int offset)
+{
+	char ch;
+        if (lseek(fd, offset, 0) < 0)
+                return 0;
+        if (read(fd, &ch, 1) < 1)
+                return 0;
+        return 1;
+}
+static int find_size(int fd)
+{
+        unsigned int high, low;
+        low = 0;
+        for (high = 1; high > 0 && valid_offset(fd, high); high *= 2)
+                low = high;
+        while (low < high - 1) {
+                const int mid = (low + high) / 2;
+                if (valid_offset(fd, mid))
+                        low = mid;
+                else
+                        high = mid;
+        }
+        return (low + 1);
+}
+/* return size in pages, to avoid integer overflow */
+static long get_size(const char *file)
+{
+	int fd;
+	long size;
+
+	if ((fd = open(file, O_RDONLY)) < 0)
+		perror_msg_and_die("%s", file);
+	if (ioctl(fd, BLKGETSIZE, &size) >= 0) {
+		int sectors_per_page = pagesize / 512;
+
+		size /= sectors_per_page;
+	} else {
+                size = find_size(fd) / pagesize;
+        }
+        close(fd);
+        return size;
+}
+int mkswap_main(int argc, char **argv)
+{
+        char *tmp;
+        struct stat statbuf;
+        int sz;
+        int maxpages;
+        int goodpages;
+        int offset;
+        int force = 0;
+        init_signature_page();          /* get pagesize */
+        applet_name = "mkswap";
+        while (argc-- > 1) {
+                argv++;
+                if (argv[0][0] != '-') {
+                        if (device_name) {
+                                int blocks_per_page = pagesize / 1024;
+                                PAGES = strtol(argv[0], &tmp, 0) / blocks_per_page;
+                                if (*tmp)
+                                        show_usage();
+                        } else
+                                device_name = argv[0];
+                } else {
+                        switch (argv[0][1]) {
+                        case 'c':
+                                check = 1;
+                                break;
+                        case 'f':
+                                force = 1;
+                                break;
+                        case 'v':
+                                version = atoi(argv[0] + 2);
+                                break;
+                        default:
+                                show_usage();
+			}
+		}
+	}
+	if (!device_name) {
+		error_msg("error: Nowhere to set up swap on?");
+		show_usage();
+	}
+	sz = get_size(device_name);
+	if (!PAGES) {
+		PAGES = sz;
+	} else if (PAGES > sz && !force) {
+		error_msg("error: size %ld is larger than device size %d",
+				PAGES * (pagesize / 1024), sz * (pagesize / 1024));
+		return EXIT_FAILURE;
+	}
+
+	if (version == -1) {
+		if (PAGES <= V0_MAX_PAGES)
+			version = 0;
+		else if (get_kernel_revision() < MAKE_VERSION(2, 1, 117))
+			version = 0;
+		else if (pagesize < 2048)
+			version = 0;
+		else
+			version = 1;
+	}
+	version = 1;
+	if (version != 0 && version != 1) {
+		error_msg("error: unknown version %d", version);
+		show_usage();
+	}
+	if (PAGES < 10) {
+		error_msg("error: swap area needs to be at least %ldkB",
+				(long) (10 * pagesize / 1024));
+		show_usage();
+	}
+#if 0
+	maxpages = ((version == 0) ? V0_MAX_PAGES : V1_MAX_PAGES);
+#else
+	if (!version)
+		maxpages = V0_MAX_PAGES;
+	else if (get_kernel_revision() >= MAKE_VERSION(2, 2, 1))
+		maxpages = V1_MAX_PAGES;
+	else {
+		maxpages = V1_OLD_MAX_PAGES;
+		if (maxpages > V1_MAX_PAGES)
+			maxpages = V1_MAX_PAGES;
+	}
+#endif
+	if (PAGES > maxpages) {
+		PAGES = maxpages;
+		error_msg("warning: truncating swap area to %ldkB",
+				PAGES * pagesize / 1024);
+	}
+
+	DEV = open(device_name, O_RDWR);
+	if (DEV < 0 || fstat(DEV, &statbuf) < 0)
+		perror_msg_and_die("%s", device_name);
+	if (!S_ISBLK(statbuf.st_mode))
+		check = 0;
+	else if (statbuf.st_rdev == 0x0300 || statbuf.st_rdev == 0x0340)
+		error_msg_and_die("Will not try to make swapdevice on '%s'", device_name);
+
+#ifdef __sparc__
+	if (!force && version == 0) {
+		/* Don't overwrite partition table unless forced */
+		unsigned char *buffer = (unsigned char *) signature_page;
+		unsigned short *q, sum;
+
+		if (read(DEV, buffer, 512) != 512)
+			error_msg_and_die("fatal: first page unreadable");
+		if (buffer[508] == 0xDA && buffer[509] == 0xBE) {
+			q = (unsigned short *) (buffer + 510);
+			for (sum = 0; q >= (unsigned short *) buffer;)
+				sum ^= *q--;
+			if (!sum) {
+				error_msg("Device '%s' contains a valid Sun disklabel.\n"
+"This probably means creating v0 swap would destroy your partition table\n"
+"No swap created. If you really want to create swap v0 on that device, use\n"
+"the -f option to force it.", device_name);
+				return EXIT_FAILURE;
+			}
+		}
+	}
+#endif
+
+	if (version == 0 || check)
+		check_blocks();
+	if (version == 0 && !bit_test_and_clear(signature_page, 0))
+		error_msg_and_die("fatal: first page unreadable");
+	if (version == 1) {
+		p->version = version;
+		p->last_page = PAGES - 1;
+		p->nr_badpages = badpages;
+	}
+
+	goodpages = PAGES - badpages - 1;
+	if (goodpages <= 0)
+		error_msg_and_die("Unable to set up swap-space: unreadable");
+	printf("Setting up swapspace version %d, size = %ld bytes\n",
+		   version, (long) (goodpages * pagesize));
+	write_signature((version == 0) ? "SWAP-SPACE" : "SWAPSPACE2");
+
+	offset = ((version == 0) ? 0 : 1024);
+	if (lseek(DEV, offset, SEEK_SET) != offset)
+		error_msg_and_die("unable to rewind swap-device");
+	if (write(DEV, (char *) signature_page + offset, pagesize - offset)
+		!= pagesize - offset)
+		error_msg_and_die("unable to write signature page");
+
+	/*
+	 * A subsequent swapon() will fail if the signature
+	 * is not actually on disk. (This is a kernel bug.)
+	 */
+	if (fsync(DEV))
+		error_msg_and_die("fsync failed");
+	return EXIT_SUCCESS;
+}
diff --git a/toolbox/swapoff.c b/toolbox/swapoff.c
new file mode 100644
index 0000000..2025b8e
--- /dev/null
+++ b/toolbox/swapoff.c
@@ -0,0 +1,152 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Mini swapon/swapoff implementation for busybox
+ *
+ *
+ * Copyright (C) 1999,2000 by Lineo, inc. and Erik Andersen
+ * Copyright (C) 1999,2000,2001 by Erik Andersen <andersee@debian.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <stdio.h>
+#include <mntent.h>
+#include <dirent.h>
+#include <errno.h>
+#include <string.h>
+#include <stdlib.h>
+#include <sys/mount.h>
+#include <stdarg.h>
+#include <sys/stat.h>
+//#include <mntent.h>
+//#include <asm/systbl.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <time.h>
+
+#if 1//__GNU_LIBRARY__ < 5
+/* libc5 doesn't have sys/swap.h, define these here. */ 
+int swapon (__const char *__path, int __flags);
+int swapoff (__const char *__path);
+#else
+//#include <sys/swap.h>
+#endif
+
+//#include "busybox.h"
+
+
+
+
+static void usage(char *prog)
+{
+	fprintf(stderr, 
+		"Usage:\n"
+ "swapoff -a [-v]                      disable all swaps\n"
+ "swapoff [-v] <special>               disable given swap\n"
+ "swapoff -h                           display help\n"
+ "swapoff -V                           display version\n\n"
+"The <special> parameter:\n"
+ "{-L label | LABEL=label}             LABEL of device to be used\n"
+ "{-U uuid  | UUID=uuid}               UUID of device to be used\n"
+ "<device>                             name of device to be used\n"
+ "<file>                               name of file to be used\n");
+}
+#define show_usage() usage(argv[0])
+
+extern void error_msg_and_die(const char *s, ...);
+extern void perror_msg_and_die(const char *s, ...);
+extern const char *applet_name;
+
+
+
+static int whichApp;
+
+static const int SWAPON_APP = 1;
+static const int SWAPOFF_APP = 2;
+
+
+static void swap_enable_disable(char *device)
+{
+	int status;
+
+	if (whichApp == SWAPON_APP)
+		status = swapon(device, 0);
+	else
+		status = swapoff(device);
+
+	if (status != 0)
+		perror_msg_and_die("swapon");
+}
+
+#define setmntent(f,m) fopen(f,m)
+#define endmntent(f) fclose(f)
+static void do_em_all()
+{
+	struct mntent *m;
+	FILE *f = setmntent("/etc/fstab", "r");
+
+	if (f == NULL)
+		perror_msg_and_die("/etc/fstab");
+	while ((m = getmntent(f)) != NULL) {
+		if (strcmp(m->mnt_type, "swap")==0) {
+			swap_enable_disable(m->mnt_fsname);
+		}
+	}
+	endmntent(f);
+	exit(EXIT_SUCCESS);
+}
+
+
+//extern int swap_on_off_main(int argc, char **argv)
+int swapoff_main(int argc, char **argv)
+{
+	applet_name = "swapoff";
+	if (strcmp(applet_name, "swapon") == 0) {
+		whichApp = SWAPON_APP;
+	} else {
+		whichApp = SWAPOFF_APP;
+	}
+
+	if (argc != 2) {
+		goto usage_and_exit;
+	}
+	argc--;
+	argv++;
+
+	/* Parse any options */
+	while (**argv == '-') {
+		while (*++(*argv))
+			switch (**argv) {
+			case 'a':
+				{
+					struct stat statBuf;
+
+					if (stat("/etc/fstab", &statBuf) < 0)
+						error_msg_and_die("/etc/fstab file missing");
+				}
+				do_em_all();
+				break;
+			default:
+				goto usage_and_exit;
+			}
+	}
+	swap_enable_disable(*argv);
+	return EXIT_SUCCESS;
+
+  usage_and_exit:
+	show_usage();
+	return EXIT_SUCCESS;
+}
diff --git a/toolbox/swapon.c b/toolbox/swapon.c
new file mode 100644
index 0000000..96bb2c8
--- /dev/null
+++ b/toolbox/swapon.c
@@ -0,0 +1,152 @@
+/* vi: set sw=4 ts=4: */
+/*
+ * Mini swapon/swapoff implementation for busybox
+ *
+ *
+ * Copyright (C) 1999,2000 by Lineo, inc. and Erik Andersen
+ * Copyright (C) 1999,2000,2001 by Erik Andersen <andersee@debian.org>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+ * General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA
+ *
+ */
+
+#include <stdio.h>
+#include <mntent.h>
+#include <dirent.h>
+#include <errno.h>
+#include <string.h>
+#include <stdlib.h>
+#include <sys/mount.h>
+#include <stdarg.h>
+#include <sys/stat.h>
+//#include <mntent.h>
+//#include <asm/systbl.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <time.h>
+
+#if 1//__GNU_LIBRARY__ < 5
+/* libc5 doesn't have sys/swap.h, define these here. */ 
+int swapon (__const char *__path, int __flags);
+int swapoff (__const char *__path);
+#else
+//#include <sys/swap.h>
+#endif
+
+//#include "busybox.h"
+
+
+
+static void usage(char *prog)
+{
+	fprintf(stderr, 
+		"Usage:\n"
+ 		"swapon -a [-e] [-v] [-f]             enable all swaps from /etc/fstab\n"
+ 		"swapon [-p priority] [-v] [-f] <special>  enable given swap\n"
+ 		"swapon -s                            display swap usage summary\n"
+ 		"swapon -h                            display helpn\n"
+ 		"swapon -V                            display version\n\n"
+		"The <special> parameter:\n"
+ 		"{-L label | LABEL=label}             LABEL of device to be used\n"
+ 		"{-U uuid  | UUID=uuid}               UUID of device to be used\n"
+ 		"<device>                             name of device to be used\n"
+ 		"<file>                               name of file to be used\n");
+}
+#define show_usage() usage(argv[0])
+
+extern void error_msg_and_die(const char *s, ...);
+extern void perror_msg_and_die(const char *s, ...);
+extern const char *applet_name;
+
+
+
+static int whichApp;
+
+static const int SWAPON_APP = 1;
+static const int SWAPOFF_APP = 2;
+
+
+static void swap_enable_disable(char *device)
+{
+	int status;
+
+	if (whichApp == SWAPON_APP)
+		status = swapon(device, 0);
+	else
+		status = swapoff(device);
+
+	if (status != 0)
+		perror_msg_and_die("swapon");
+}
+
+#define setmntent(f,m) fopen(f,m)
+#define endmntent(f) fclose(f)
+static void do_em_all()
+{
+	struct mntent *m;
+	FILE *f = setmntent("/etc/fstab", "r");
+
+	if (f == NULL)
+		perror_msg_and_die("/etc/fstab");
+	while ((m = getmntent(f)) != NULL) {
+		if (strcmp(m->mnt_type, "swap")==0) {
+			swap_enable_disable(m->mnt_fsname);
+		}
+	}
+	endmntent(f);
+	exit(EXIT_SUCCESS);
+}
+
+
+//extern int swap_on_off_main(int argc, char **argv)
+int swapon_main(int argc, char **argv)
+{
+	applet_name = "swapon";
+	if (strcmp(applet_name, "swapon") == 0) {
+		whichApp = SWAPON_APP;
+	} else {
+		whichApp = SWAPOFF_APP;
+	}
+
+	if (argc != 2) {
+		goto usage_and_exit;
+	}
+	argc--;
+	argv++;
+
+	/* Parse any options */
+	while (**argv == '-') {
+		while (*++(*argv))
+			switch (**argv) {
+			case 'a':
+				{
+					struct stat statBuf;
+
+					if (stat("/etc/fstab", &statBuf) < 0)
+						error_msg_and_die("/etc/fstab file missing");
+				}
+				do_em_all();
+				break;
+			default:
+				goto usage_and_exit;
+			}
+	}
+	swap_enable_disable(*argv);
+	return EXIT_SUCCESS;
+
+  usage_and_exit:
+	show_usage();
+	return EXIT_SUCCESS;
+}
-- 
1.7.9.5

