From 5740c974f69d6717aa05d9c83ca92136d6103a89 Mon Sep 17 00:00:00 2001
From: Kaizhen <kli@mozilla.com>
Date: Sat, 11 Jan 2014 17:07:16 +0800
Subject: [PATCH 04/12] Bug 864931 - Rewrite net worker in C++.

---
 dom/network/src/NetUtils.cpp              |  181 ++++
 dom/network/src/NetUtils.h                |   71 ++
 dom/network/src/moz.build                 |    2 +
 dom/system/gonk/NetworkService.js         |   33 +-
 dom/system/gonk/NetworkUtils.cpp          | 1268 +++++++++++++++++++++++++++++
 dom/system/gonk/NetworkUtils.h            |  285 +++++++
 dom/system/gonk/NetworkWorker.cpp         |  257 ++++++
 dom/system/gonk/NetworkWorker.h           |   40 +
 dom/system/gonk/SystemWorkerManager.cpp   |  169 ----
 dom/system/gonk/moz.build                 |    4 +-
 dom/system/gonk/nsINetworkWorker.idl      |   18 +
 dom/webidl/NetworkOptions.webidl          |   84 ++
 dom/webidl/moz.build                      |    1 +
 dom/wifi/NetUtils.cpp                     |  139 ----
 dom/wifi/NetUtils.h                       |   60 --
 dom/wifi/WifiUtils.cpp                    |    2 +-
 dom/wifi/WifiUtils.h                      |    2 +-
 dom/wifi/moz.build                        |    1 -
 toolkit/library/nsStaticXULComponents.cpp |    1 +
 19 files changed, 2232 insertions(+), 386 deletions(-)
 create mode 100644 dom/network/src/NetUtils.cpp
 create mode 100644 dom/network/src/NetUtils.h
 create mode 100644 dom/system/gonk/NetworkUtils.cpp
 create mode 100644 dom/system/gonk/NetworkUtils.h
 create mode 100644 dom/system/gonk/NetworkWorker.cpp
 create mode 100644 dom/system/gonk/NetworkWorker.h
 create mode 100644 dom/system/gonk/nsINetworkWorker.idl
 create mode 100644 dom/webidl/NetworkOptions.webidl
 delete mode 100644 dom/wifi/NetUtils.cpp
 delete mode 100644 dom/wifi/NetUtils.h

diff --git a/dom/network/src/NetUtils.cpp b/dom/network/src/NetUtils.cpp
new file mode 100644
index 0000000..ce86abe
--- /dev/null
+++ b/dom/network/src/NetUtils.cpp
@@ -0,0 +1,181 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "NetUtils.h"
+#include <dlfcn.h>
+#include <errno.h>
+#include <cutils/properties.h>
+#include "prinit.h"
+#include "mozilla/Assertions.h"
+#include "nsDebug.h"
+
+static void* sNetUtilsLib;
+static PRCallOnceType sInitNetUtilsLib;
+
+static PRStatus
+InitNetUtilsLib()
+{
+  sNetUtilsLib = dlopen("/system/lib/libnetutils.so", RTLD_LAZY);
+  // We might fail to open the hardware lib. That's OK.
+  return PR_SUCCESS;
+}
+
+static void*
+GetNetUtilsLibHandle()
+{
+  PR_CallOnce(&sInitNetUtilsLib, InitNetUtilsLib);
+  return sNetUtilsLib;
+}
+
+// static
+void*
+NetUtils::GetSharedLibrary()
+{
+  void* netLib = GetNetUtilsLibHandle();
+  if (!netLib) {
+    NS_WARNING("No /system/lib/libnetutils.so");
+  }
+  return netLib;
+}
+
+// static
+int32_t
+NetUtils::SdkVersion()
+{
+  char propVersion[PROPERTY_VALUE_MAX];
+  property_get("ro.build.version.sdk", propVersion, "0");
+  int32_t version = strtol(propVersion, nullptr, 10);
+  return version;
+}
+
+DEFINE_DLFUNC(ifc_enable, int32_t, const char*)
+DEFINE_DLFUNC(ifc_disable, int32_t, const char*)
+DEFINE_DLFUNC(ifc_configure, int32_t, const char*, in_addr_t, uint32_t,
+              in_addr_t, in_addr_t, in_addr_t)
+DEFINE_DLFUNC(ifc_reset_connections, int32_t, const char*, const int32_t)
+DEFINE_DLFUNC(ifc_set_default_route, int32_t, const char*, in_addr_t)
+DEFINE_DLFUNC(ifc_add_route, int32_t, const char*, const char*, uint32_t, const char*)
+DEFINE_DLFUNC(ifc_remove_route, int32_t, const char*, const char*, uint32_t, const char*)
+DEFINE_DLFUNC(ifc_remove_host_routes, int32_t, const char*)
+DEFINE_DLFUNC(ifc_remove_default_route, int32_t, const char*)
+DEFINE_DLFUNC(dhcp_stop, int32_t, const char*)
+
+int32_t NetUtils::do_ifc_enable(const char *ifname)
+{
+  USE_DLFUNC(ifc_enable)
+  return ifc_enable(ifname);
+}
+
+int32_t NetUtils::do_ifc_disable(const char *ifname)
+{
+  USE_DLFUNC(ifc_disable)
+  return ifc_disable(ifname);
+}
+
+int32_t NetUtils::do_ifc_configure(const char *ifname,
+                                       in_addr_t address,
+                                       uint32_t prefixLength,
+                                       in_addr_t gateway,
+                                       in_addr_t dns1,
+                                       in_addr_t dns2)
+{
+  USE_DLFUNC(ifc_configure)
+  int32_t ret = ifc_configure(ifname, address, prefixLength, gateway, dns1, dns2);
+  return ret;
+}
+
+int32_t NetUtils::do_ifc_reset_connections(const char *ifname,
+                                               const int32_t resetMask)
+{
+  USE_DLFUNC(ifc_reset_connections)
+  return ifc_reset_connections(ifname, resetMask);
+}
+
+int32_t NetUtils::do_ifc_set_default_route(const char *ifname,
+                                           in_addr_t gateway)
+{
+  USE_DLFUNC(ifc_set_default_route)
+  return ifc_set_default_route(ifname, gateway);
+}
+
+int32_t NetUtils::do_ifc_add_route(const char *ifname,
+                                   const char *dst,
+                                   uint32_t prefixLength,
+                                   const char *gateway)
+{
+  USE_DLFUNC(ifc_add_route)
+  return ifc_add_route(ifname, dst, prefixLength, gateway);
+}
+
+int32_t NetUtils::do_ifc_remove_route(const char *ifname,
+                                      const char *dst,
+                                      uint32_t prefixLength,
+                                      const char *gateway)
+{
+  USE_DLFUNC(ifc_remove_route)
+  return ifc_remove_route(ifname, dst, prefixLength, gateway);
+}
+
+int32_t NetUtils::do_ifc_remove_host_routes(const char *ifname)
+{
+  USE_DLFUNC(ifc_remove_host_routes)
+  return ifc_remove_host_routes(ifname);
+}
+
+int32_t NetUtils::do_ifc_remove_default_route(const char *ifname)
+{
+  USE_DLFUNC(ifc_remove_default_route)
+  return ifc_remove_default_route(ifname);
+}
+
+int32_t NetUtils::do_dhcp_stop(const char *ifname)
+{
+  USE_DLFUNC(dhcp_stop)
+  return dhcp_stop(ifname);
+}
+
+int32_t NetUtils::do_dhcp_do_request(const char *ifname,
+                                         char *ipaddr,
+                                         char *gateway,
+                                         uint32_t *prefixLength,
+                                         char *dns1,
+                                         char *dns2,
+                                         char *server,
+                                         uint32_t  *lease,
+                                         char* vendorinfo)
+{
+  int32_t ret = -1;
+  uint32_t sdkVersion = SdkVersion();
+
+  if (sdkVersion == 15) {
+    // ICS
+    // http://androidxref.com/4.0.4/xref/system/core/libnetutils/dhcp_utils.c#149
+    DEFINE_DLFUNC(dhcp_do_request, int32_t, const char*, char*, char*,  uint32_t*, char*, char*, char*, uint32_t*)
+    USE_DLFUNC(dhcp_do_request)
+    vendorinfo[0] = '\0';
+
+    ret = dhcp_do_request(ifname, ipaddr, gateway, prefixLength, dns1, dns2,
+                          server, lease);
+  } else if (sdkVersion == 16 || sdkVersion == 17) {
+    // JB 4.1 and 4.2
+    // http://androidxref.com/4.1.2/xref/system/core/libnetutils/dhcp_utils.c#175
+    // http://androidxref.com/4.2.2_r1/xref/system/core/include/netutils/dhcp.h#26
+    DEFINE_DLFUNC(dhcp_do_request, int32_t, const char*, char*, char*,  uint32_t*, char*, char*, char*, uint32_t*, char*)
+    USE_DLFUNC(dhcp_do_request)
+    ret = dhcp_do_request(ifname, ipaddr, gateway, prefixLength, dns1, dns2,
+                          server, lease, vendorinfo);
+  } else if (sdkVersion == 18) {
+    // JB 4.3
+    // http://androidxref.com/4.3_r2.1/xref/system/core/libnetutils/dhcp_utils.c#181
+    DEFINE_DLFUNC(dhcp_do_request, int32_t, const char*, char*, char*,  uint32_t*, char**, char*, uint32_t*, char*, char*)
+    USE_DLFUNC(dhcp_do_request)
+    char *dns[3] = {dns1, dns2, nullptr};
+    char domains[PROPERTY_VALUE_MAX];
+    ret = dhcp_do_request(ifname, ipaddr, gateway, prefixLength, dns,
+                          server, lease, vendorinfo, domains);
+  } else {
+    NS_WARNING("Unable to perform do_dhcp_request: unsupported sdk version!");
+  }
+  return ret;
+}
diff --git a/dom/network/src/NetUtils.h b/dom/network/src/NetUtils.h
new file mode 100644
index 0000000..816c089
--- /dev/null
+++ b/dom/network/src/NetUtils.h
@@ -0,0 +1,71 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+/**
+ * Abstraction on top of the network support from libnetutils that we
+ * use to set up network connections.
+ */
+
+#ifndef NetUtils_h
+#define NetUtils_h
+
+#include "arpa/inet.h"
+
+// Copied from ifc.h
+#define RESET_IPV4_ADDRESSES 0x01
+#define RESET_IPV6_ADDRESSES 0x02
+#define RESET_ALL_ADDRESSES  (RESET_IPV4_ADDRESSES | RESET_IPV6_ADDRESSES)
+
+// Implements netutils functions. No need for an abstract class here since we
+// only have a one sdk specific method (dhcp_do_request)
+class NetUtils
+{
+public:
+  static void* GetSharedLibrary();
+
+  int32_t do_ifc_enable(const char *ifname);
+  int32_t do_ifc_disable(const char *ifname);
+  int32_t do_ifc_configure(const char *ifname,
+                           in_addr_t address,
+                           uint32_t prefixLength,
+                           in_addr_t gateway,
+                           in_addr_t dns1,
+                           in_addr_t dns2);
+  int32_t do_ifc_reset_connections(const char *ifname, const int32_t resetMask);
+  int32_t do_ifc_set_default_route(const char *ifname, in_addr_t gateway);
+  int32_t do_ifc_add_route(const char *ifname,
+                           const char *dst,
+                           uint32_t prefixLength,
+                           const char *gateway);
+  int32_t do_ifc_remove_route(const char *ifname,
+                              const char *dst,
+                              uint32_t prefixLength,
+                              const char *gateway);
+  int32_t do_ifc_remove_host_routes(const char *ifname);
+  int32_t do_ifc_remove_default_route(const char *ifname);
+  int32_t do_dhcp_stop(const char *ifname);
+  int32_t do_dhcp_do_request(const char *ifname,
+                             char *ipaddr,
+                             char *gateway,
+                             uint32_t *prefixLength,
+                             char *dns1,
+                             char *dns2,
+                             char *server,
+                             uint32_t  *lease,
+                             char* vendorinfo);
+
+  static int32_t SdkVersion();
+};
+
+// Defines a function type with the right arguments and return type.
+#define DEFINE_DLFUNC(name, ret, args...) typedef ret (*FUNC##name)(args);
+
+// Set up a dlsymed function ready to use.
+#define USE_DLFUNC(name)                                                      \
+  FUNC##name name = (FUNC##name) dlsym(GetSharedLibrary(), #name);            \
+  if (!name) {                                                                \
+    MOZ_ASSUME_UNREACHABLE("Symbol not found in shared library : " #name);         \
+  }
+
+#endif // NetUtils_h
diff --git a/dom/network/src/moz.build b/dom/network/src/moz.build
index f8e5dae..b3d21a1 100644
--- a/dom/network/src/moz.build
+++ b/dom/network/src/moz.build
@@ -6,6 +6,7 @@
 
 EXPORTS.mozilla.dom.network += [
     'Constants.h',
+    'NetUtils.h',
     'TCPServerSocketChild.h',
     'TCPServerSocketParent.h',
     'TCPSocketChild.h',
@@ -17,6 +18,7 @@ EXPORTS.mozilla.dom.network += [
 
 UNIFIED_SOURCES += [
     'Connection.cpp',
+    'NetUtils.cpp',
     'TCPServerSocketChild.cpp',
     'TCPServerSocketParent.cpp',
     'TCPSocketChild.cpp',
diff --git a/dom/system/gonk/NetworkService.js b/dom/system/gonk/NetworkService.js
index e58d994..40d07a9 100644
--- a/dom/system/gonk/NetworkService.js
+++ b/dom/system/gonk/NetworkService.js
@@ -51,14 +51,18 @@ function debug(msg) {
  */
 function NetworkService() {
   if(DEBUG) debug("Starting net_worker.");
-  this.worker = new ChromeWorker("resource://gre/modules/net_worker.js");
-  this.worker.onmessage = this.handleWorkerMessage.bind(this);
-  this.worker.onerror = function onerror(event) {
-    if(DEBUG) debug("Received error from worker: " + event.filename +
-                    ":" + event.lineno + ": " + event.message + "\n");
-    // Prevent the event from bubbling any further.
-    event.preventDefault();
-  };
+  let networkWorker = Cc["@mozilla.org/network/worker;1"];
+  var self = this;
+  if (networkWorker) {
+    let networkListener = {
+      onEvent: function(event) {
+        self.handleWorkerMessage(event);
+      }
+    };
+
+    this.worker = networkWorker.getService(Ci.nsINetworkWorker);
+    this.worker.start(networkListener);
+  }
 
   // Callbacks to invoke when a reply arrives from the net_worker.
   this.controlCallbacks = Object.create(null);
@@ -90,11 +94,10 @@ NetworkService.prototype = {
     this.worker.postMessage(params);
   },
 
-  handleWorkerMessage: function handleWorkerMessage(e) {
-    if(DEBUG) debug("NetworkManager received message from worker: " + JSON.stringify(e.data));
-    let response = e.data;
+  handleWorkerMessage: function handleWorkerMessage(response) {
+    if(DEBUG) debug("NetworkManager received message from worker: " + JSON.stringify(response));
     let id = response.id;
-    if (id === 'broadcast') {
+    if (response.broadcast === true) {
       Services.obs.notifyObservers(null, response.topic, response.reason);
       return;
     }
@@ -467,8 +470,10 @@ NetworkService.prototype = {
     let params = {
       cmd: "updateUpStream",
       isAsync: true,
-      previous: previous,
-      current: current
+      preInternalIfname: previous.internalIfname,
+      preExternalIfname: previous.externalIfname,
+      curInternalIfname: current.internalIfname,
+      curExternalIfname: current.externalIfname,
     };
 
     this.controlMessage(params, function (data) {
diff --git a/dom/system/gonk/NetworkUtils.cpp b/dom/system/gonk/NetworkUtils.cpp
new file mode 100644
index 0000000..ed66aa7
--- /dev/null
+++ b/dom/system/gonk/NetworkUtils.cpp
@@ -0,0 +1,1268 @@
+/* Copyright 2012 Mozilla Foundation and Mozilla contributors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "NetworkUtils.h"
+
+#include <android/log.h>
+#include <cutils/properties.h>
+#include "mozilla/dom/network/NetUtils.h"
+
+#define USE_DEBUG 1
+
+#define WARN(args...)   __android_log_print(ANDROID_LOG_WARN,  "NetworlUtils", ## args)
+#define ERROR(args...)  __android_log_print(ANDROID_LOG_ERROR,  "NetworkUtils", ## args)
+
+#if USE_DEBUG
+#define DEBUG(args...)  __android_log_print(ANDROID_LOG_DEBUG, "NetworkUtils" , ## args)
+#else
+#define DEBUG(args...)
+#endif
+
+using namespace mozilla::dom;
+using namespace mozilla::ipc;
+
+static const char* PERSIST_SYS_USB_CONFIG_PROPERTY = "persist.sys.usb.config";
+static const char* SYS_USB_CONFIG_PROPERTY         = "sys.usb.config";
+static const char* SYS_USB_STATE_PROPERTY          = "sys.usb.state";
+
+static const char* USB_FUNCTION_RNDIS  = "rndis";
+static const char* USB_FUNCTION_ADB    = "adb";
+
+// Use this command to continue the function chain.
+static const char* DUMMY_COMMAND = "tether status";
+
+// Retry 20 times (2 seconds) for usb state transition.
+static const uint32_t USB_FUNCTION_RETRY_TIMES = 20;
+// Check "sys.usb.state" every 100ms.
+static const uint32_t USB_FUNCTION_RETRY_INTERVAL = 100;
+
+// 1xx - Requested action is proceeding
+static const uint32_t NETD_COMMAND_PROCEEDING   = 100;
+// 2xx - Requested action has been successfully completed
+static const uint32_t NETD_COMMAND_OKAY         = 200;
+// 4xx - The command is accepted but the requested action didn't
+// take place.
+static const uint32_t NETD_COMMAND_FAIL         = 400;
+// 5xx - The command syntax or parameters error
+static const uint32_t NETD_COMMAND_ERROR        = 500;
+// 6xx - Unsolicited broadcasts
+static const uint32_t NETD_COMMAND_UNSOLICITED  = 600;
+
+// Broadcast messages
+static const uint32_t NETD_COMMAND_INTERFACE_CHANGE     = 600;
+static const uint32_t NETD_COMMAND_BANDWIDTH_CONTROLLER = 601;
+
+static const char* INTERFACE_DELIMIT = "\0";
+static const char* USB_CONFIG_DELIMIT = ",";
+static const char* NETD_MESSAGE_DELIMIT = " ";
+
+static const uint32_t BUF_SIZE = 1024;
+
+static uint32_t SDK_VERSION;
+
+inline uint32_t netdResponseType(uint32_t code)
+{
+  return (code / 100) * 100;
+}
+
+inline bool isBroadcastMessage(uint32_t code)
+{
+  uint32_t type = netdResponseType(code);
+  return type == NETD_COMMAND_UNSOLICITED;
+}
+
+inline bool isError(uint32_t code)
+{
+  uint32_t type = netdResponseType(code);
+  return type != NETD_COMMAND_PROCEEDING && type != NETD_COMMAND_OKAY;
+}
+
+inline bool isComplete(uint32_t code)
+{
+  uint32_t type = netdResponseType(code);
+  return type != NETD_COMMAND_PROCEEDING;
+}
+
+inline bool isProceeding(uint32_t code)
+{
+  uint32_t type = netdResponseType(code);
+  return type == NETD_COMMAND_PROCEEDING;
+}
+
+struct IFProperties {
+  char gateway[PROPERTY_VALUE_MAX];
+  char dns1[PROPERTY_VALUE_MAX];
+  char dns2[PROPERTY_VALUE_MAX];
+};
+
+typedef Tuple3<NetdCommand*, CALLBACK, CommandChain*> QueueData;
+
+static NetworkUtils* gNetworkUtils;
+
+static nsTArray<QueueData> gCommandQueue;
+static char gCurrentCommand[MAX_COMMAND_SIZE];
+static CALLBACK gCurrentCallback = NULL;
+static CommandChain* gCurrentChain = NULL;
+static bool gPending = false;
+static nsTArray<nsCString> gReason;
+
+static void next(CommandChain* aChain, bool aError, NetworkResultOptions& aResult)
+{
+  if (aError) {
+    ERROR_CALLBACK onError = aChain->getErrorCallback();
+    if(onError) {
+      aResult.mError = true;
+      (*onError)(aChain->getParams(), aResult);
+    }
+    delete aChain;
+    return;
+  }
+  COMMAND f = aChain->getNextCommand();
+  if (!f) {
+    delete aChain;
+    return;
+  }
+
+  (*f)(aChain, next, aResult);
+}
+
+/**
+ * Send command to netd.
+ */
+static void nextNetdCommand()
+{
+  if (gCommandQueue.IsEmpty() || gPending) {
+    return;
+  }
+  QueueData data = gCommandQueue[0];
+  gCommandQueue.RemoveElementAt(0);
+
+  sprintf(gCurrentCommand, "%s", data.a->mData);
+  gCurrentCallback = data.b;
+  gCurrentChain = data.c;
+
+  gPending = true;
+
+  DEBUG("Sending \'%s\' command to netd.", gCurrentCommand);
+  SendNetdCommand(data.a);
+}
+
+static void doCommand(const char* aCommand, CommandChain* aChain, CALLBACK aCallback)
+{
+  DEBUG("Preparing to send \'%s\' command...", aCommand);
+
+  NetdCommand* netdCommand = new NetdCommand();
+
+  // Android JB version adds sequence number to netd command.
+  if (SDK_VERSION >= 16) {
+    sprintf((char*)netdCommand->mData, "0 %s", aCommand);
+  } else {
+    sprintf((char*)netdCommand->mData, "%s", aCommand);
+  }
+  netdCommand->mSize = strlen((char*)netdCommand->mData) + 1;
+
+  gCommandQueue.AppendElement(QueueData(netdCommand, aCallback, aChain));
+
+  nextNetdCommand();
+}
+
+static void postMessage(NetworkResultOptions& aResult)
+{
+  (*(gNetworkUtils->mPostCallback))(aResult);
+}
+
+static void postMessage(NetworkParams& aOptions, NetworkResultOptions& aResult)
+{
+  aResult.mId = aOptions.mId;
+  (*(gNetworkUtils->mPostCallback))(aResult);
+}
+
+static void sendBroadcastMessage(uint32_t code, char* reason)
+{
+  NetworkResultOptions result;
+  switch(code) {
+    case NETD_COMMAND_INTERFACE_CHANGE:
+      result.mTopic = NS_ConvertUTF8toUTF16("netd-interface-change");
+      break;
+    case NETD_COMMAND_BANDWIDTH_CONTROLLER:
+      result.mTopic = NS_ConvertUTF8toUTF16("netd-bandwidth-control");
+      break;
+    default:
+      return;
+  }
+
+  result.mBroadcast = true;
+  result.mReason = NS_ConvertUTF8toUTF16(reason);
+  postMessage(result);
+}
+
+/**
+ * Helper function to get the bit length from given mask.
+ */
+static uint32_t getMaskLength(const uint32_t mask)
+{
+  uint32_t netmask = ntohl(mask);
+  uint32_t len = 0;
+  while (netmask & 0x80000000) {
+    len++;
+    netmask = netmask << 1;
+  }
+  return len;
+}
+
+/**
+ * Helper function to split string by seperator, store split result as an nsTArray.
+ */
+static void split(char* str, const char* sep, nsTArray<nsCString>& result)
+{
+  char *s = strtok(str, sep);
+  while (s != NULL) {
+    result.AppendElement(s);
+    s = strtok(NULL, sep);
+  }
+}
+
+/**
+ * Helper function that implement join function.
+ */
+static void join(nsTArray<nsCString>& array, const char* sep, char* result)
+{
+  if (array.Length() > 0) {
+    strcpy(result, array[0].get());
+    for (uint32_t i = 1; i < array.Length(); i++) {
+      strcat(result, sep);
+      strcat(result, array[i].get());
+    }
+  }
+}
+
+/**
+ * Get network interface properties from the system property table.
+ */
+static void getIFProperties(const char* ifname, IFProperties& prop)
+{
+  char key[PROPERTY_KEY_MAX];
+  sprintf(key, "net.%s.gw", ifname);
+  property_get(key, prop.gateway, "");
+  sprintf(key, "net.%s.dns1", ifname);
+  property_get(key, prop.dns1, "");
+  sprintf(key, "net.%s.dns2", ifname);
+  property_get(key, prop.dns2, "");
+}
+
+/*
+ * Netd command function
+ */
+#define GET_CHAR(prop) NS_ConvertUTF16toUTF8(aChain->getParams().prop).get()
+#define GET_FIELD(prop) aChain->getParams().prop
+
+void wifiFirmwareReload(CommandChain* aChain, CALLBACK aCallback, NetworkResultOptions& aResult)
+{
+  char command[MAX_COMMAND_SIZE];
+  sprintf(command, "softap fwreload %s %s", GET_CHAR(mIfname), GET_CHAR(mMode));
+
+  doCommand(command, aChain, aCallback);
+}
+
+void startAccessPointDriver(CommandChain* aChain, CALLBACK aCallback, NetworkResultOptions& aResult)
+{
+  // Skip the command for sdk version >= 16.
+  if (SDK_VERSION >= 16) {
+    aResult.mResultCode = 0;
+    aResult.mResultReason = NS_ConvertUTF8toUTF16("");
+    aCallback(aChain, false, aResult);
+    return;
+  }
+
+  char command[MAX_COMMAND_SIZE];
+  sprintf(command, "softap start %s", GET_CHAR(mIfname));
+
+  doCommand(command, aChain, aCallback);
+}
+
+void stopAccessPointDriver(CommandChain* aChain, CALLBACK aCallback, NetworkResultOptions& aResult)
+{
+  // Skip the command for sdk version >= 16.
+  if (SDK_VERSION >= 16) {
+    aResult.mResultCode = 0;
+    aResult.mResultReason = NS_ConvertUTF8toUTF16("");
+    aCallback(aChain, false, aResult);
+    return;
+  }
+
+  char command[MAX_COMMAND_SIZE];
+  sprintf(command, "softap stop %s", GET_CHAR(mIfname));
+
+  doCommand(command, aChain, aCallback);
+}
+
+/**
+ * Command format for sdk version < 16
+ *   Arguments:
+ *     argv[2] - wlan interface
+ *     argv[3] - SSID
+ *     argv[4] - Security
+ *     argv[5] - Key
+ *     argv[6] - Channel
+ *     argv[7] - Preamble
+ *     argv[8] - Max SCB
+ *
+ * Command format for sdk version >= 16
+ *   Arguments:
+ *     argv[2] - wlan interface
+ *     argv[3] - SSID
+ *     argv[4] - Security
+ *     argv[5] - Key
+ */
+void setAccessPoint(CommandChain* aChain, CALLBACK aCallback, NetworkResultOptions& aResult)
+{
+  char command[MAX_COMMAND_SIZE];
+  if (SDK_VERSION >= 16) {
+    sprintf(command, "softap set %s \"%s\" %s \"%s\"",
+                     GET_CHAR(mIfname),
+                     GET_CHAR(mSsid),
+                     GET_CHAR(mSecurity),
+                     GET_CHAR(mKey));
+  } else {
+    sprintf(command, "softap set %s %s \"%s\" %s \"%s\" 6 0 8",
+                     GET_CHAR(mIfname),
+                     GET_CHAR(mWifictrlinterfacename),
+                     GET_CHAR(mSsid),
+                     GET_CHAR(mSecurity),
+                     GET_CHAR(mKey));
+  }
+
+  doCommand(command, aChain, aCallback);
+}
+
+void cleanUpStream(CommandChain* aChain, CALLBACK aCallback, NetworkResultOptions& aResult)
+{
+  char command[MAX_COMMAND_SIZE];
+  sprintf(command, "nat disable %s %s 0", GET_CHAR(mPreInternalIfname), GET_CHAR(mPreExternalIfname));
+
+  doCommand(command, aChain, aCallback);
+}
+
+void createUpStream(CommandChain* aChain, CALLBACK aCallback, NetworkResultOptions& aResult)
+{
+  char command[MAX_COMMAND_SIZE];
+  sprintf(command, "nat enable %s %s 0", GET_CHAR(mCurInternalIfname), GET_CHAR(mCurExternalIfname));
+
+  doCommand(command, aChain, aCallback);
+}
+
+void startSoftAP(CommandChain* aChain, CALLBACK aCallback, NetworkResultOptions& aResult)
+{
+  const char* command= "softap startap";
+  doCommand(command, aChain, aCallback);
+}
+
+void stopSoftAP(CommandChain* aChain, CALLBACK aCallback, NetworkResultOptions& aResult)
+{
+  const char* command= "softap stopap";
+  doCommand(command, aChain, aCallback);
+}
+
+void getRxBytes(CommandChain* aChain, CALLBACK aCallback, NetworkResultOptions& aResult)
+{
+  char command[MAX_COMMAND_SIZE];
+  sprintf(command, "interface readrxcounter %s", GET_CHAR(mIfname));
+
+  doCommand(command, aChain, aCallback);
+}
+
+void getTxBytes(CommandChain* aChain, CALLBACK aCallback, NetworkResultOptions& aResult)
+{
+  NetworkParams& options = aChain->getParams();
+  options.mRxBytes = atof(NS_ConvertUTF16toUTF8(aResult.mResultReason).get());
+
+  char command[MAX_COMMAND_SIZE];
+  sprintf(command, "interface readtxcounter %s", GET_CHAR(mIfname));
+
+  doCommand(command, aChain, aCallback);
+}
+
+void enableAlarm(CommandChain* aChain, CALLBACK aCallback, NetworkResultOptions& aResult)
+{
+  const char* command= "bandwidth enable";
+  doCommand(command, aChain, aCallback);
+}
+
+void disableAlarm(CommandChain* aChain, CALLBACK aCallback, NetworkResultOptions& aResult)
+{
+  const char* command= "bandwidth disable";
+  doCommand(command, aChain, aCallback);
+}
+
+void setQuota(CommandChain* aChain, CALLBACK aCallback, NetworkResultOptions& aResult)
+{
+  char command[MAX_COMMAND_SIZE];
+  sprintf(command, "bandwidth setiquota %s %lld", GET_CHAR(mIfname), atoll("0xffffffffffffffff"));
+
+  doCommand(command, aChain, aCallback);
+}
+
+void removeQuota(CommandChain* aChain, CALLBACK aCallback, NetworkResultOptions& aResult)
+{
+  char command[MAX_COMMAND_SIZE];
+  sprintf(command, "bandwidth removeiquota %s", GET_CHAR(mIfname));
+
+  doCommand(command, aChain, aCallback);
+}
+
+void setAlarm(CommandChain* aChain, CALLBACK aCallback, NetworkResultOptions& aResult)
+{
+  char command[MAX_COMMAND_SIZE];
+  sprintf(command, "bandwidth setinterfacealert %s %ld", GET_CHAR(mIfname), GET_FIELD(mThreshold));
+
+  doCommand(command, aChain, aCallback);
+}
+
+void setInterfaceUp(CommandChain* aChain, CALLBACK aCallback, NetworkResultOptions& aResult)
+{
+  char command[MAX_COMMAND_SIZE];
+  if (SDK_VERSION >= 16) {
+    sprintf(command, "interface setcfg %s %s %s %s",
+                     GET_CHAR(mIfname),
+                     GET_CHAR(mIp),
+                     GET_CHAR(mPrefix),
+                     GET_CHAR(mLink));
+  } else {
+    sprintf(command, "interface setcfg %s %s %s [%s]",
+                     GET_CHAR(mIfname),
+                     GET_CHAR(mIp),
+                     GET_CHAR(mPrefix),
+                     GET_CHAR(mLink));
+  }
+  doCommand(command, aChain, aCallback);
+}
+
+void tetherInterface(CommandChain* aChain, CALLBACK aCallback, NetworkResultOptions& aResult)
+{
+  char command[MAX_COMMAND_SIZE];
+  sprintf(command, "tether interface add %s", GET_CHAR(mIfname));
+
+  doCommand(command, aChain, aCallback);
+}
+
+void preTetherInterfaceList(CommandChain* aChain, CALLBACK aCallback, NetworkResultOptions& aResult)
+{
+  char command[MAX_COMMAND_SIZE];
+  if (SDK_VERSION >= 16) {
+    sprintf(command, "tether interface list");
+  } else {
+    sprintf(command, "tether interface list 0");
+  }
+
+  doCommand(command, aChain, aCallback);
+}
+
+void postTetherInterfaceList(CommandChain* aChain, CALLBACK aCallback, NetworkResultOptions& aResult)
+{
+  // Send the dummy command to continue the function chain.
+  char command[MAX_COMMAND_SIZE];
+  sprintf(command, "%s", DUMMY_COMMAND);
+
+  char buf[BUF_SIZE];
+  const char* reason = NS_ConvertUTF16toUTF8(aResult.mResultReason).get();
+  memcpy(buf, reason, strlen(reason));
+  split(buf, INTERFACE_DELIMIT, GET_FIELD(mInterfaceList));
+
+  doCommand(command, aChain, aCallback);
+}
+
+void setIpForwardingEnabled(CommandChain* aChain, CALLBACK aCallback, NetworkResultOptions& aResult)
+{
+  char command[MAX_COMMAND_SIZE];
+
+  if (GET_FIELD(mEnable)) {
+    sprintf(command, "ipfwd enable");
+  } else {
+    // Don't disable ip forwarding because others interface still need it.
+    // Send the dummy command to continue the function chain.
+    if (GET_FIELD(mInterfaceList).Length() > 1) {
+      sprintf(command, "%s", DUMMY_COMMAND);
+    } else {
+      sprintf(command, "ipfwd disable");
+    }
+  }
+
+  doCommand(command, aChain, aCallback);
+}
+
+void tetheringStatus(CommandChain* aChain, CALLBACK aCallback, NetworkResultOptions& aResult)
+{
+  const char* command= "tether status";
+  doCommand(command, aChain, aCallback);
+}
+
+void stopTethering(CommandChain* aChain, CALLBACK aCallback, NetworkResultOptions& aResult)
+{
+  char command[MAX_COMMAND_SIZE];
+
+  // Don't stop tethering because others interface still need it.
+  // Send the dummy to continue the function chain.
+  if (GET_FIELD(mInterfaceList).Length() > 1) {
+    sprintf(command, "%s", DUMMY_COMMAND);
+  } else {
+    sprintf(command, "tether stop");
+  }
+
+  doCommand(command, aChain, aCallback);
+}
+
+void startTethering(CommandChain* aChain, CALLBACK aCallback, NetworkResultOptions& aResult)
+{
+  char command[MAX_COMMAND_SIZE];
+
+  // We don't need to start tethering again.
+  // Send the dummy command to continue the function chain.
+  if (aResult.mResultReason.Find("started") != kNotFound) {
+    sprintf(command, "%s", DUMMY_COMMAND);
+  } else {
+    sprintf(command, "tether start %s %s", GET_CHAR(mWifiStartIp), GET_CHAR(mWifiEndIp));
+
+    // If usbStartIp/usbEndIp is not valid, don't append them since
+    // the trailing white spaces will be parsed to extra empty args
+    // See: http://androidxref.com/4.3_r2.1/xref/system/core/libsysutils/src/FrameworkListener.cpp#78
+    if (!GET_FIELD(mUsbStartIp).IsEmpty() && !GET_FIELD(mUsbEndIp).IsEmpty()) {
+      sprintf(command, "%s %s %s", command, GET_CHAR(mUsbStartIp), GET_CHAR(mUsbEndIp));
+    }
+  }
+
+  doCommand(command, aChain, aCallback);
+}
+
+void untetherInterface(CommandChain* aChain, CALLBACK aCallback, NetworkResultOptions& aResult)
+{
+  char command[MAX_COMMAND_SIZE];
+  sprintf(command, "tether interface remove %s", GET_CHAR(mIfname));
+
+  doCommand(command, aChain, aCallback);
+}
+
+void setDnsForwarders(CommandChain* aChain, CALLBACK aCallback, NetworkResultOptions& aResult)
+{
+  char command[MAX_COMMAND_SIZE];
+  sprintf(command, "tether dns set %s %s", GET_CHAR(mDns1), GET_CHAR(mDns2));
+
+  doCommand(command, aChain, aCallback);
+}
+
+void enableNat(CommandChain* aChain, CALLBACK aCallback, NetworkResultOptions& aResult)
+{
+  char command[MAX_COMMAND_SIZE];
+  sprintf(command, "nat enable %s %s 0", GET_CHAR(mInternalIfname), GET_CHAR(mExternalIfname));
+
+  doCommand(command, aChain, aCallback);
+}
+
+void disableNat(CommandChain* aChain, CALLBACK aCallback, NetworkResultOptions& aResult)
+{
+  char command[MAX_COMMAND_SIZE];
+  sprintf(command, "nat disable %s %s 0", GET_CHAR(mInternalIfname), GET_CHAR(mExternalIfname));
+
+  doCommand(command, aChain, aCallback);
+}
+
+#undef GET_CHAR
+#undef GET_FIELD
+
+static COMMAND gWifiFailChain[] = {stopSoftAP,
+                                   setIpForwardingEnabled,
+                                   stopTethering};
+
+static COMMAND gUSBFailChain[] = {stopSoftAP,
+                                  setIpForwardingEnabled,
+                                  stopTethering};
+
+/*
+ * Netd command success/fail function
+ */
+#define ASSIGN_FIELD(prop)  aResult.prop = aChain->getParams().prop;
+#define ASSIGN_FIELD_VALUE(prop, value)  aResult.prop = value;
+
+#define RUN_CHAIN(param, cmds, err)  uint32_t size = sizeof(cmds) / sizeof(COMMAND);  \
+                                     CommandChain* chain = new CommandChain(param, cmds, size, err);  \
+                                     NetworkResultOptions result;  \
+                                     next(chain, false, result);
+
+void wifiTetheringFail(NetworkParams& aOptions, NetworkResultOptions& aResult)
+{
+  // Notify the main thread.
+  postMessage(aOptions, aResult);
+
+  // If one of the stages fails, we try roll back to ensure
+  // we don't leave the network systems in limbo.
+  ASSIGN_FIELD_VALUE(mEnable, false)
+  RUN_CHAIN(aOptions, gWifiFailChain, NULL)
+}
+
+void wifiTetheringSuccess(CommandChain* aChain, CALLBACK aCallback, NetworkResultOptions& aResult)
+{
+  ASSIGN_FIELD(mEnable)
+  postMessage(aChain->getParams(), aResult);
+}
+
+void usbTetheringFail(NetworkParams& aOptions, NetworkResultOptions& aResult)
+{
+  // Notify the main thread.
+  postMessage(aOptions, aResult);
+  // Try to roll back to ensure
+  // we don't leave the network systems in limbo.
+  // This parameter is used to disable ipforwarding.
+  {
+    aOptions.mEnable = false;
+    RUN_CHAIN(aOptions, gUSBFailChain, NULL)
+  }
+
+  // Disable usb rndis function.
+  {
+    NetworkParams options;
+    options.mEnable = false;
+    options.mReport = false;
+    gNetworkUtils->enableUsbRndis(options);
+  }
+}
+
+void usbTetheringSuccess(CommandChain* aChain, CALLBACK aCallback, NetworkResultOptions& aResult)
+{
+  ASSIGN_FIELD(mEnable)
+  postMessage(aChain->getParams(), aResult);
+}
+
+void networkInterfaceStatsFail(NetworkParams& aOptions, NetworkResultOptions& aResult)
+{
+  postMessage(aOptions, aResult);
+}
+
+void networkInterfaceStatsSuccess(CommandChain* aChain, CALLBACK aCallback, NetworkResultOptions& aResult)
+{
+  ASSIGN_FIELD(mRxBytes)
+  ASSIGN_FIELD_VALUE(mTxBytes, atof(NS_ConvertUTF16toUTF8(aResult.mResultReason).get()))
+  postMessage(aChain->getParams(), aResult);
+}
+
+void networkInterfaceAlarmFail(NetworkParams& aOptions, NetworkResultOptions& aResult)
+{
+  postMessage(aOptions, aResult);
+}
+
+void networkInterfaceAlarmSuccess(CommandChain* aChain, CALLBACK aCallback, NetworkResultOptions& aResult)
+{
+  // TODO : error is not used , and it is conflict with boolean type error.
+  // params.error = parseFloat(params.resultReason);
+  postMessage(aChain->getParams(), aResult);
+}
+
+void updateUpStreamFail(NetworkParams& aOptions, NetworkResultOptions& aResult)
+{
+  postMessage(aOptions, aResult);
+}
+
+void updateUpStreamSuccess(CommandChain* aChain, CALLBACK aCallback, NetworkResultOptions& aResult)
+{
+  ASSIGN_FIELD(mCurExternalIfname)
+  ASSIGN_FIELD(mCurInternalIfname)
+  postMessage(aChain->getParams(), aResult);
+}
+
+void setDhcpServerFail(NetworkParams& aOptions, NetworkResultOptions& aResult)
+{
+  aResult.mSuccess = false;
+  postMessage(aOptions, aResult);
+}
+
+void setDhcpServerSuccess(CommandChain* aChain, CALLBACK aCallback, NetworkResultOptions& aResult)
+{
+  aResult.mSuccess = true;
+  postMessage(aChain->getParams(), aResult);
+}
+
+void wifiOperationModeFail(NetworkParams& aOptions, NetworkResultOptions& aResult)
+{
+  postMessage(aOptions, aResult);
+}
+
+void wifiOperationModeSuccess(CommandChain* aChain, CALLBACK aCallback, NetworkResultOptions& aResult)
+{
+  postMessage(aChain->getParams(), aResult);
+}
+
+#undef ASSIGN_FIELD
+#undef ASSIGN_FIELD_VALUE
+
+static COMMAND gUSBEnableChain[] = {setInterfaceUp,
+                                    enableNat,
+                                    setIpForwardingEnabled,
+                                    tetherInterface,
+                                    tetheringStatus,
+                                    startTethering,
+                                    setDnsForwarders,
+                                    usbTetheringSuccess};
+
+static COMMAND gUSBDisableChain[] = {untetherInterface,
+                                     preTetherInterfaceList,
+                                     postTetherInterfaceList,
+                                     disableNat,
+                                     setIpForwardingEnabled,
+                                     stopTethering,
+                                     usbTetheringSuccess};
+
+static COMMAND gWifiEnableChain[] = {wifiFirmwareReload,
+                                     startAccessPointDriver,
+                                     setAccessPoint,
+                                     startSoftAP,
+                                     setInterfaceUp,
+                                     tetherInterface,
+                                     setIpForwardingEnabled,
+                                     tetheringStatus,
+                                     startTethering,
+                                     setDnsForwarders,
+                                     enableNat,
+                                     wifiTetheringSuccess};
+
+static COMMAND gWifiDisableChain[] = {stopSoftAP,
+                                      stopAccessPointDriver,
+                                      wifiFirmwareReload,
+                                      untetherInterface,
+                                      preTetherInterfaceList,
+                                      postTetherInterfaceList,
+                                      disableNat,
+                                      setIpForwardingEnabled,
+                                      stopTethering,
+                                      wifiTetheringSuccess};
+
+static COMMAND gStartDhcpServerChain[] = {setInterfaceUp,
+                                          startTethering,
+                                          setDhcpServerSuccess};
+
+static COMMAND gStopDhcpServerChain[] = {stopTethering,
+                                         setDhcpServerSuccess};
+
+static COMMAND gNetworkInterfaceStatsChain[] = {getRxBytes,
+                                                getTxBytes,
+                                                networkInterfaceStatsSuccess};
+
+static COMMAND gNetworkInterfaceEnableAlarmChain[] = {enableAlarm,
+                                                      setQuota,
+                                                      setAlarm,
+                                                      networkInterfaceAlarmSuccess};
+
+static COMMAND gNetworkInterfaceDisableAlarmChain[] = {removeQuota,
+                                                       disableAlarm,
+                                                       networkInterfaceAlarmSuccess};
+
+static COMMAND gNetworkInterfaceSetAlarmChain[] = {setAlarm,
+                                                   networkInterfaceAlarmSuccess};
+
+static COMMAND gWifiOperationModeChain[] = {wifiFirmwareReload,
+                                            wifiOperationModeSuccess};
+
+static COMMAND gUpdateUpStreamChain[] = {cleanUpStream,
+                                         createUpStream,
+                                         updateUpStreamSuccess};
+
+NetworkUtils::NetworkUtils(POSTMESSAGE post)
+ : mPostCallback(post)
+{
+  mNetUtils = new NetUtils();
+
+  char value[PROPERTY_VALUE_MAX];
+  property_get("ro.build.version.sdk", value, NULL);
+  SDK_VERSION = atoi(value);
+
+  gNetworkUtils = this;
+}
+
+NetworkUtils::~NetworkUtils()
+{
+  delete mNetUtils;
+}
+
+#define GET_CHAR(prop) NS_ConvertUTF16toUTF8(aOptions.prop).get()
+
+void NetworkUtils::ExecuteCommand(NetworkParams aOptions)
+{
+  DEBUG("received message: %s", GET_CHAR(mCmd));
+  bool ret = true;
+
+  if (aOptions.mCmd.EqualsLiteral("removeNetworkRoute")) {
+    removeNetworkRoute(aOptions);                                            // OK
+  } else if (aOptions.mCmd.EqualsLiteral("setDNS")) {
+    setDNS(aOptions);                                                        // OK
+  } else if (aOptions.mCmd.EqualsLiteral("setDefaultRouteAndDNS")) {
+    setDefaultRouteAndDNS(aOptions);                                         // Ok
+  } else if (aOptions.mCmd.EqualsLiteral("removeDefaultRoute")) {
+    removeDefaultRoute(aOptions);                                            // OK
+  } else if (aOptions.mCmd.EqualsLiteral("addHostRoute")) {
+    addHostRoute(aOptions);                                                  // Ok
+  } else if (aOptions.mCmd.EqualsLiteral("removeHostRoute")) {
+    removeHostRoute(aOptions);                                               // Ok
+  } else if (aOptions.mCmd.EqualsLiteral("removeHostRoutes")) {
+    removeHostRoutes(aOptions);                                              // Ok
+  } else if (aOptions.mCmd.EqualsLiteral("getNetworkInterfaceStats")) {
+    getNetworkInterfaceStats(aOptions);                                      // Ok
+  } else if (aOptions.mCmd.EqualsLiteral("setNetworkInterfaceAlarm")) {
+    setNetworkInterfaceAlarm(aOptions);
+  } else if (aOptions.mCmd.EqualsLiteral("enableNetworkInterfaceAlarm")) {
+    enableNetworkInterfaceAlarm(aOptions);
+  } else if (aOptions.mCmd.EqualsLiteral("disableNetworkInterfaceAlarm")) {
+    disableNetworkInterfaceAlarm(aOptions);
+  } else if (aOptions.mCmd.EqualsLiteral("setWifiOperationMode")) {
+    setWifiOperationMode(aOptions);                                          // Ok
+  } else if (aOptions.mCmd.EqualsLiteral("setDhcpServer")) {
+    setDhcpServer(aOptions);                                                 // Ok
+  } else if (aOptions.mCmd.EqualsLiteral("setWifiTethering")) {
+    setWifiTethering(aOptions);                                              // Disable Not Ok
+  } else if (aOptions.mCmd.EqualsLiteral("setUSBTethering")) {
+    setUSBTethering(aOptions);                                               // Disable Not OK
+  } else if (aOptions.mCmd.EqualsLiteral("enableUsbRndis")) {
+    enableUsbRndis(aOptions);                                                // Ok
+  } else if (aOptions.mCmd.EqualsLiteral("updateUpStream")) {
+    updateUpStream(aOptions);                                                // Ok
+  } else {
+    WARN("unknon message");
+    return;
+  }
+
+  if (!aOptions.mIsAsync) {
+    NetworkResultOptions result;
+    result.mRet = ret;
+    postMessage(aOptions, result);
+  }
+}
+
+/**
+ * Handle received data from netd.
+ */
+void NetworkUtils::onNetdMessage(const NetdCommand& aCommand)
+{
+  char* data = (char*)aCommand.mData;
+
+  // get code & reason.
+  char* result = strtok(data, NETD_MESSAGE_DELIMIT);
+
+  if (!result) {
+    nextNetdCommand();
+    return;
+  }
+  uint32_t code = atoi(result);
+  char* reason = NULL;
+
+  if (!isBroadcastMessage(code) && SDK_VERSION >= 16) {
+    strtok(NULL, NETD_MESSAGE_DELIMIT);
+    reason = strtok(NULL, "\0");
+  }
+
+  if (isBroadcastMessage(code)) {
+    DEBUG("Receiving broadcast message from netd.");
+    DEBUG("          ==> Code: %d  Reason: %s", code, reason);
+    sendBroadcastMessage(code, reason);
+    nextNetdCommand();
+    return;
+  }
+
+   // Set pending to false before we handle next command.
+  DEBUG("Receiving \"%s\" command response from netd.", gCurrentCommand);
+  DEBUG("          ==> Code: %d  Reason: %s", code, reason);
+
+  gReason.AppendElement(nsCString(reason));
+
+  // 1xx response code regards as command is proceeding, we need to wait for
+  // final response code such as 2xx, 4xx and 5xx before sending next command.
+  if (isProceeding(code)) {
+    return;
+  }
+
+  if (isComplete(code)) {
+    gPending = false;
+  }
+
+  if (gCurrentCallback) {
+    char buf[BUF_SIZE];
+    join(gReason, INTERFACE_DELIMIT, buf);
+
+    NetworkResultOptions result;
+    result.mResultCode = code;
+    result.mResultReason = NS_ConvertUTF8toUTF16(buf);
+    join(gReason, INTERFACE_DELIMIT, buf);
+    (*gCurrentCallback)(gCurrentChain, isError(code), result);
+    gReason.Clear();
+  }
+
+  // Handling pending commands if any.
+  if (isComplete(code)) {
+    nextNetdCommand();
+  }
+}
+
+/**
+ * Start/Stop DHCP server.
+ */
+bool NetworkUtils::setDhcpServer(NetworkParams& aOptions)
+{
+  if (aOptions.mEnabled) {
+    aOptions.mWifiStartIp = aOptions.mStartIp;
+    aOptions.mWifiEndIp = aOptions.mEndIp;
+    aOptions.mIp = aOptions.mServerIp;
+    aOptions.mPrefix = aOptions.mMaskLength;
+    aOptions.mLink = NS_ConvertUTF8toUTF16("up");
+
+    RUN_CHAIN(aOptions, gStartDhcpServerChain, setDhcpServerFail)
+  } else {
+    RUN_CHAIN(aOptions, gStopDhcpServerChain, setDhcpServerFail)
+  }
+  return true;
+}
+
+/**
+ * Set DNS servers for given network interface.
+ */
+bool NetworkUtils::setDNS(NetworkParams& aOptions)
+{
+  IFProperties interfaceProperties;
+  getIFProperties(GET_CHAR(mIfname), interfaceProperties);
+
+  if (aOptions.mDns1_str.IsEmpty()) {
+    property_set("net.dns1", interfaceProperties.dns1);
+  } else {
+    property_set("net.dns1", GET_CHAR(mDns1_str));
+  }
+
+  if (aOptions.mDns2_str.IsEmpty()) {
+    property_set("net.dns2", interfaceProperties.dns2);
+  } else {
+    property_set("net.dns2", GET_CHAR(mDns2_str));
+  }
+
+  // Bump the DNS change property.
+  char dnschange[PROPERTY_VALUE_MAX];
+  property_get("net.dnschange", dnschange, "0");
+
+  char num[PROPERTY_VALUE_MAX];
+  sprintf(num, "%d", atoi(dnschange) + 1);
+  property_set("net.dnschange", num);
+
+  return true;
+}
+
+/**
+ * Set default route and DNS servers for given network interface.
+ */
+bool NetworkUtils::setDefaultRouteAndDNS(NetworkParams& aOptions)
+{
+  if (!aOptions.mOldIfname.IsEmpty()) {
+    mNetUtils->do_ifc_remove_default_route(GET_CHAR(mOldIfname));
+  }
+
+  IFProperties ifprops;
+  getIFProperties(GET_CHAR(mIfname), ifprops);
+
+  if (aOptions.mGateway_str.IsEmpty()) {
+    mNetUtils->do_ifc_set_default_route(GET_CHAR(mIfname), inet_addr(ifprops.gateway));
+  } else {
+    mNetUtils->do_ifc_set_default_route(GET_CHAR(mIfname), inet_addr(GET_CHAR(mGateway_str)));
+  }
+
+  setDNS(aOptions);
+  return true;
+}
+
+/**
+ * Remove default route for given network interface.
+ */
+bool NetworkUtils::removeDefaultRoute(NetworkParams& aOptions)
+{
+  mNetUtils->do_ifc_remove_default_route(GET_CHAR(mIfname));
+  return true;
+}
+
+/**
+ * Add host route for given network interface.
+ */
+bool NetworkUtils::addHostRoute(NetworkParams& aOptions)
+{
+  uint32_t length = aOptions.mHostnames.Length();
+  for (uint32_t i = 0; i < length; i++) {
+    mNetUtils->do_ifc_add_route(GET_CHAR(mIfname), GET_CHAR(mHostnames[i]), 32, GET_CHAR(mGateway));
+  }
+  return true;
+}
+
+/**
+ * Remove host route for given network interface.
+ */
+bool NetworkUtils::removeHostRoute(NetworkParams& aOptions)
+{
+  uint32_t length = aOptions.mHostnames.Length();
+  for (uint32_t i = 0; i < length; i++) {
+    mNetUtils->do_ifc_remove_route(GET_CHAR(mIfname), GET_CHAR(mHostnames[i]), 32, GET_CHAR(mGateway));
+  }
+  return true;
+}
+
+/**
+ * Remove the routes associated with the named interface.
+ */
+bool NetworkUtils::removeHostRoutes(NetworkParams& aOptions)
+{
+  mNetUtils->do_ifc_remove_host_routes(GET_CHAR(mIfname));
+  return true;
+}
+
+bool NetworkUtils::removeNetworkRoute(NetworkParams& aOptions)
+{
+  uint32_t ip = inet_addr(GET_CHAR(mIp));
+  uint32_t netmask = inet_addr(GET_CHAR(mNetmask));
+  uint32_t subnet = ip & netmask;
+  uint32_t prefixLength = getMaskLength(netmask);
+  const char* gateway = "0.0.0.0";
+  struct in_addr addr;
+  addr.s_addr = subnet;
+  const char* dst = inet_ntoa(addr);
+
+  mNetUtils->do_ifc_remove_default_route(GET_CHAR(mIfname));
+  mNetUtils->do_ifc_remove_route(GET_CHAR(mIfname), dst, prefixLength, gateway);
+  return true;
+}
+
+bool NetworkUtils::getNetworkInterfaceStats(NetworkParams& aOptions)
+{
+  DEBUG("getNetworkInterfaceStats: %s", GET_CHAR(mIfname));
+  aOptions.mRxBytes = -1;
+  aOptions.mTxBytes = -1;
+
+  RUN_CHAIN(aOptions, gNetworkInterfaceStatsChain, networkInterfaceStatsFail);
+  return  true;
+}
+
+bool NetworkUtils::setNetworkInterfaceAlarm(NetworkParams& aOptions)
+{
+  DEBUG("setNetworkInterfaceAlarms: %s", GET_CHAR(mIfname));
+  RUN_CHAIN(aOptions, gNetworkInterfaceSetAlarmChain, networkInterfaceAlarmFail);
+  return true;
+}
+
+bool NetworkUtils::enableNetworkInterfaceAlarm(NetworkParams& aOptions)
+{
+  DEBUG("enableNetworkInterfaceAlarm: %s", GET_CHAR(mIfname));
+  RUN_CHAIN(aOptions, gNetworkInterfaceEnableAlarmChain, networkInterfaceAlarmFail);
+  return true;
+}
+
+bool NetworkUtils::disableNetworkInterfaceAlarm(NetworkParams& aOptions)
+{
+  DEBUG("disableNetworkInterfaceAlarms: %s", GET_CHAR(mIfname));
+  RUN_CHAIN(aOptions, gNetworkInterfaceDisableAlarmChain, networkInterfaceAlarmFail);
+  return true;
+}
+
+/**
+ * handling main thread's reload Wifi firmware request
+ */
+bool NetworkUtils::setWifiOperationMode(NetworkParams& aOptions)
+{
+  DEBUG("setWifiOperationMode: %s %s", GET_CHAR(mIfname), GET_CHAR(mMode));
+  RUN_CHAIN(aOptions, gWifiOperationModeChain, wifiOperationModeFail);
+  return true;
+}
+
+/**
+ * handling main thread's enable/disable WiFi Tethering request
+ */
+bool NetworkUtils::setWifiTethering(NetworkParams& aOptions)
+{
+  bool enable = aOptions.mEnable;
+  IFProperties interfaceProperties;
+  getIFProperties(GET_CHAR(mExternalIfname), interfaceProperties);
+
+  if (strcmp(interfaceProperties.dns1, "")) {
+    aOptions.mDns1 = NS_ConvertUTF8toUTF16(interfaceProperties.dns1);
+  }
+  if (strcmp(interfaceProperties.dns2, "")) {
+    aOptions.mDns2 = NS_ConvertUTF8toUTF16(interfaceProperties.dns2);
+  }
+  dumpParams(aOptions, "WIFI");
+
+  if (enable) {
+    DEBUG("Starting Wifi Tethering on %s <-> %s",
+           GET_CHAR(mInternalIfname), GET_CHAR(mExternalIfname));
+    RUN_CHAIN(aOptions, gWifiEnableChain, wifiTetheringFail)
+  } else {
+    DEBUG("Stopping Wifi Tethering on %s <-> %s",
+           GET_CHAR(mInternalIfname), GET_CHAR(mExternalIfname));
+    RUN_CHAIN(aOptions, gWifiDisableChain, wifiTetheringFail)
+  }
+  return true;
+}
+
+bool NetworkUtils::setUSBTethering(NetworkParams& aOptions)
+{
+  bool enable = aOptions.mEnable;
+  IFProperties interfaceProperties;
+  getIFProperties(GET_CHAR(mExternalIfname), interfaceProperties);
+
+  if (strcmp(interfaceProperties.dns1, "")) {
+    aOptions.mDns1 = NS_ConvertUTF8toUTF16(interfaceProperties.dns1);
+  }
+  if (strcmp(interfaceProperties.dns2, "")) {
+    aOptions.mDns2 = NS_ConvertUTF8toUTF16(interfaceProperties.dns2);
+  }
+  dumpParams(aOptions, "USB");
+
+  if (enable) {
+    DEBUG("Starting USB Tethering on %s <-> %s",
+           GET_CHAR(mInternalIfname), GET_CHAR(mExternalIfname));
+    RUN_CHAIN(aOptions, gUSBEnableChain, usbTetheringFail)
+  } else {
+    DEBUG("Stopping USB Tethering on %s <-> %s",
+           GET_CHAR(mInternalIfname), GET_CHAR(mExternalIfname));
+    RUN_CHAIN(aOptions, gUSBDisableChain, usbTetheringFail)
+  }
+  return true;
+}
+
+void NetworkUtils::checkUsbRndisState(NetworkParams& aOptions)
+{
+  static uint32_t retry = 0;
+
+  char currentState[PROPERTY_VALUE_MAX];
+  property_get(SYS_USB_STATE_PROPERTY, currentState, NULL);
+
+  nsTArray<nsCString> stateFuncs;
+  split(currentState, USB_CONFIG_DELIMIT, stateFuncs);
+  bool rndisPresent = stateFuncs.Contains(nsCString(USB_FUNCTION_RNDIS));
+
+  if (aOptions.mEnable == rndisPresent) {
+    NetworkResultOptions result;
+    result.mEnable = aOptions.mEnable;
+    result.mResult = true;
+    postMessage(aOptions, result);
+    retry = 0;
+    return;
+  }
+  if (retry < USB_FUNCTION_RETRY_TIMES) {
+    retry++;
+    usleep(USB_FUNCTION_RETRY_INTERVAL * 1000);
+    checkUsbRndisState(aOptions);
+    return;
+  }
+
+  NetworkResultOptions result;
+  result.mResult = false;
+  postMessage(aOptions, result);
+  retry = 0;
+}
+
+/**
+ * Modify usb function's property to turn on USB RNDIS function
+ */
+bool NetworkUtils::enableUsbRndis(NetworkParams& aOptions)
+{
+  bool report = aOptions.mReport;
+
+  // For some reason, rndis doesn't play well with diag,modem,nmea.
+  // So when turning rndis on, we set sys.usb.config to either "rndis"
+  // or "rndis,adb". When turning rndis off, we go back to
+  // persist.sys.usb.config.
+  //
+  // On the otoro/unagi, persist.sys.usb.config should be one of:
+  //
+  //    diag,modem,nmea,mass_storage
+  //    diag,modem,nmea,mass_storage,adb
+  //
+  // When rndis is enabled, sys.usb.config should be one of:
+  //
+  //    rdnis
+  //    rndis,adb
+  //
+  // and when rndis is disabled, it should revert to persist.sys.usb.config
+
+  char currentConfig[PROPERTY_VALUE_MAX];
+  property_get(SYS_USB_CONFIG_PROPERTY, currentConfig, NULL);
+
+  nsTArray<nsCString> configFuncs;
+  split(currentConfig, USB_CONFIG_DELIMIT, configFuncs);
+
+  char persistConfig[PROPERTY_VALUE_MAX];
+  property_get(PERSIST_SYS_USB_CONFIG_PROPERTY, persistConfig, NULL);
+
+  nsTArray<nsCString> persistFuncs;
+  split(persistConfig, USB_CONFIG_DELIMIT, persistFuncs);
+
+  if (aOptions.mEnable) {
+    configFuncs.Clear();
+    configFuncs.AppendElement(nsCString(USB_FUNCTION_RNDIS));
+    if (persistFuncs.Contains(nsCString(USB_FUNCTION_ADB))) {
+      configFuncs.AppendElement(nsCString(USB_FUNCTION_ADB));
+    }
+  } else {
+    // We're turning rndis off, revert back to the persist setting.
+    // adb will already be correct there, so we don't need to do any
+    // further adjustments.
+    configFuncs = persistFuncs;
+  }
+
+  char newConfig[PROPERTY_VALUE_MAX] = "";
+  property_get(SYS_USB_CONFIG_PROPERTY, currentConfig, NULL);
+  join(configFuncs, USB_CONFIG_DELIMIT, newConfig);
+  if (strcmp(currentConfig, newConfig)) {
+    property_set(SYS_USB_CONFIG_PROPERTY, newConfig);
+  }
+
+  // Trigger the timer to check usb state and report the result to NetworkManager.
+  if (report) {
+    usleep(USB_FUNCTION_RETRY_INTERVAL * 1000);
+    checkUsbRndisState(aOptions);
+  }
+  return true;
+}
+
+/**
+ * handling upstream interface change event.
+ */
+bool NetworkUtils::updateUpStream(NetworkParams& aOptions)
+{
+  RUN_CHAIN(aOptions, gUpdateUpStreamChain, updateUpStreamFail)
+  return true;
+}
+
+void NetworkUtils::dumpParams(NetworkParams& aOptions, const char* aType)
+{
+#ifdef USE_DEBUG
+  DEBUG("Dump params:");
+  DEBUG("     ifname: %s", GET_CHAR(mIfname));
+  DEBUG("     ip: %s", GET_CHAR(mIp));
+  DEBUG("     link: %s", GET_CHAR(mLink));
+  DEBUG("     prefix: %s", GET_CHAR(mPrefix));
+  DEBUG("     wifiStartIp: %s", GET_CHAR(mWifiStartIp));
+  DEBUG("     wifiEndIp: %s", GET_CHAR(mWifiEndIp));
+  DEBUG("     usbStartIp: %s", GET_CHAR(mUsbStartIp));
+  DEBUG("     usbEndIp: %s", GET_CHAR(mUsbEndIp));
+  DEBUG("     dnsserver1: %s", GET_CHAR(mDns1));
+  DEBUG("     dnsserver2: %s", GET_CHAR(mDns2));
+  DEBUG("     internalIfname: %s", GET_CHAR(mInternalIfname));
+  DEBUG("     externalIfname: %s", GET_CHAR(mExternalIfname));
+  if (!strcmp(aType, "WIFI")) {
+    DEBUG("     wifictrlinterfacename: %s", GET_CHAR(mWifictrlinterfacename));
+    DEBUG("     ssid: %s", GET_CHAR(mSsid));
+    DEBUG("     security: %s", GET_CHAR(mSecurity));
+    DEBUG("     key: %s", GET_CHAR(mKey));
+  }
+#endif
+}
+
+#undef GET_CHAR
diff --git a/dom/system/gonk/NetworkUtils.h b/dom/system/gonk/NetworkUtils.h
new file mode 100644
index 0000000..a268c97
--- /dev/null
+++ b/dom/system/gonk/NetworkUtils.h
@@ -0,0 +1,285 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef NetworkUtils_h
+#define NetworkUtils_h
+
+#include "nsString.h"
+#include "mozilla/dom/NetworkOptionsBinding.h"
+#include "mozilla/dom/network/NetUtils.h"
+#include "mozilla/ipc/Netd.h"
+#include "nsTArray.h"
+
+class NetworkParams;
+class CommandChain;
+
+using namespace mozilla::dom;
+
+typedef void (*POSTMESSAGE)(NetworkResultOptions& aResult);
+typedef void (*CALLBACK)(CommandChain*, bool, NetworkResultOptions& aResult);
+typedef void (*ERROR_CALLBACK)(NetworkParams& aOptions, NetworkResultOptions& aResult);
+typedef void (*COMMAND)(CommandChain*, CALLBACK, NetworkResultOptions& aResult);
+
+class NetworkParams
+{
+public:
+  NetworkParams() {
+  }
+
+  NetworkParams(const NetworkParams& aOther) {
+    mIp = aOther.mIp;
+    mCmd = aOther.mCmd;
+    mDns1_str = aOther.mDns1_str;
+    mDns2_str = aOther.mDns2_str;
+    mGateway = aOther.mGateway;
+    mGateway_str = aOther.mGateway_str;
+    mHostnames = aOther.mHostnames;
+    mId = aOther.mId;
+    mIfname = aOther.mIfname;
+    mNetmask = aOther.mNetmask;
+    mOldIfname = aOther.mOldIfname;
+    mMode = aOther.mMode;
+    mReport = aOther.mReport;
+    mIsAsync = aOther.mIsAsync;
+    mEnabled = aOther.mEnabled;
+    mWifictrlinterfacename = aOther.mWifictrlinterfacename;
+    mInternalIfname = aOther.mInternalIfname;
+    mExternalIfname = aOther.mExternalIfname;
+    mEnable = aOther.mEnable;
+    mSsid = aOther.mSsid;
+    mSecurity = aOther.mSecurity;
+    mKey = aOther.mKey;
+    mPrefix = aOther.mPrefix;
+    mLink = aOther.mLink;
+    mInterfaceList = aOther.mInterfaceList;
+    mWifiStartIp = aOther.mWifiStartIp;
+    mWifiEndIp = aOther.mWifiEndIp;
+    mUsbStartIp = aOther.mUsbStartIp;
+    mUsbEndIp = aOther.mUsbEndIp;
+    mDns1 = aOther.mDns1;
+    mDns2 = aOther.mDns2;
+    mRxBytes = aOther.mRxBytes;
+    mTxBytes = aOther.mTxBytes;
+    mDate = aOther.mDate;
+    mStartIp = aOther.mStartIp;
+    mEndIp = aOther.mEndIp;
+    mServerIp = aOther.mServerIp;
+    mMaskLength = aOther.mMaskLength;
+    mPreInternalIfname = aOther.mPreInternalIfname;
+    mPreExternalIfname = aOther.mPreExternalIfname;
+    mCurInternalIfname = aOther.mCurInternalIfname;
+    mCurExternalIfname = aOther.mCurExternalIfname;
+    mThreshold = aOther.mThreshold;
+  }
+  
+  NetworkParams(const NetworkCommandOptions& aOther) {
+
+#define COPY_SEQUENCE_FIELD(prop)                                                            \
+    if (aOther.prop.WasPassed()) {                                                           \
+      mozilla::dom::Sequence<nsString > const & currentValue = aOther.prop.InternalValue();  \
+      uint32_t length = currentValue.Length();                                               \
+      for (uint32_t idx = 0; idx < length; idx++) {                                          \
+        mHostnames.AppendElement(currentValue[idx]);                                         \
+      }                                                                                      \
+    }
+
+#define COPY_OPT_STRING_FIELD(prop, defaultValue)       \
+    if (aOther.prop.WasPassed()) {                      \
+      if (aOther.prop.Value().EqualsLiteral("null")) {  \
+        prop = defaultValue;                            \
+      } else {                                          \
+        prop = aOther.prop.Value();                     \
+      }                                                 \
+    } else {                                            \
+      prop = defaultValue;                              \
+    }
+
+#define COPY_OPT_FIELD(prop, defaultValue)            \
+    if (aOther.prop.WasPassed()) {                    \
+      prop = aOther.prop.Value();                     \
+    } else {                                          \
+      prop = defaultValue;                            \
+    }
+
+#define COPY_FIELD(prop) prop = aOther.prop;
+
+    COPY_FIELD(mId)
+    COPY_FIELD(mCmd)
+    COPY_OPT_STRING_FIELD(mDns1_str, EmptyString())
+    COPY_OPT_STRING_FIELD(mDns2_str, EmptyString())
+    COPY_OPT_STRING_FIELD(mGateway, EmptyString())
+    COPY_OPT_STRING_FIELD(mGateway_str, EmptyString())
+    COPY_SEQUENCE_FIELD(mHostnames)
+    COPY_OPT_STRING_FIELD(mIfname, EmptyString())
+    COPY_OPT_STRING_FIELD(mIp, EmptyString())
+    COPY_OPT_STRING_FIELD(mNetmask, EmptyString())
+    COPY_OPT_STRING_FIELD(mOldIfname, EmptyString())
+    COPY_OPT_STRING_FIELD(mMode, EmptyString())
+    COPY_OPT_FIELD(mReport, false)
+    COPY_OPT_FIELD(mIsAsync, true)
+    COPY_OPT_FIELD(mEnabled, false)
+    COPY_OPT_STRING_FIELD(mWifictrlinterfacename, EmptyString())
+    COPY_OPT_STRING_FIELD(mInternalIfname, EmptyString())
+    COPY_OPT_STRING_FIELD(mExternalIfname, EmptyString())
+    COPY_OPT_FIELD(mEnable, false)
+    COPY_OPT_STRING_FIELD(mSsid, EmptyString())
+    COPY_OPT_STRING_FIELD(mSecurity, EmptyString())
+    COPY_OPT_STRING_FIELD(mKey, EmptyString())
+    COPY_OPT_STRING_FIELD(mPrefix, EmptyString())
+    COPY_OPT_STRING_FIELD(mLink, EmptyString())
+    COPY_SEQUENCE_FIELD(mInterfaceList)
+    COPY_OPT_STRING_FIELD(mWifiStartIp, EmptyString())
+    COPY_OPT_STRING_FIELD(mWifiEndIp, EmptyString())
+    COPY_OPT_STRING_FIELD(mUsbStartIp, EmptyString())
+    COPY_OPT_STRING_FIELD(mUsbEndIp, EmptyString())
+    COPY_OPT_STRING_FIELD(mDns1, EmptyString())
+    COPY_OPT_STRING_FIELD(mDns2, EmptyString())
+    COPY_OPT_FIELD(mRxBytes, -1)
+    COPY_OPT_FIELD(mTxBytes, -1)
+    COPY_OPT_STRING_FIELD(mDate, EmptyString())
+    COPY_OPT_STRING_FIELD(mStartIp, EmptyString())
+    COPY_OPT_STRING_FIELD(mEndIp, EmptyString())
+    COPY_OPT_STRING_FIELD(mServerIp, EmptyString())
+    COPY_OPT_STRING_FIELD(mMaskLength, EmptyString())
+    COPY_OPT_STRING_FIELD(mPreInternalIfname, EmptyString())
+    COPY_OPT_STRING_FIELD(mPreExternalIfname, EmptyString())
+    COPY_OPT_STRING_FIELD(mCurInternalIfname, EmptyString())
+    COPY_OPT_STRING_FIELD(mCurExternalIfname, EmptyString())
+    COPY_OPT_FIELD(mThreshold, -1)
+
+#undef COPY_SEQUENCE_FIELD
+#undef COPY_OPT_STRING_FIELD
+#undef COPY_OPT_FIELD
+#undef COPY_FIELD
+  }
+
+  int32_t mId;
+  nsString mCmd;
+  nsString mDns1_str;
+  nsString mDns2_str;
+  nsString mGateway;
+  nsString mGateway_str;
+  nsTArray<nsString> mHostnames;
+  nsString mIfname;
+  nsString mIp;
+  nsString mNetmask;
+  nsString mOldIfname;
+  nsString mMode;
+  bool mReport;
+  bool mIsAsync;
+  bool mEnabled;
+  nsString mWifictrlinterfacename;
+  nsString mInternalIfname;
+  nsString mExternalIfname;
+  bool mEnable;
+  nsString mSsid;
+  nsString mSecurity;
+  nsString mKey;
+  nsString mPrefix;
+  nsString mLink;
+  nsTArray<nsCString> mInterfaceList;
+  nsString mWifiStartIp;
+  nsString mWifiEndIp;
+  nsString mUsbStartIp;
+  nsString mUsbEndIp;
+  nsString mDns1;
+  nsString mDns2;
+  float mRxBytes;
+  float mTxBytes;
+  nsString mDate;
+  nsString mStartIp;
+  nsString mEndIp;
+  nsString mServerIp;
+  nsString mMaskLength;
+  nsString mPreInternalIfname;
+  nsString mPreExternalIfname;
+  nsString mCurInternalIfname;
+  nsString mCurExternalIfname;
+  long mThreshold;
+};
+
+// CommandChain store the necessary information to execute command one by one.
+// Including :
+// 1. Command parameters.
+// 2. Command list.
+// 3. Error callback function.
+// 4. Index of current execution command.
+class CommandChain MOZ_FINAL
+{
+public:
+  CommandChain(const NetworkParams& aParams,
+               COMMAND aCmds[],
+               uint32_t aLength,
+               ERROR_CALLBACK aError) 
+  : mIndex(-1)
+  , mParams(aParams)
+  , mCommands(aCmds)
+  , mLength(aLength)
+  , mError(aError) {
+  }
+
+  NetworkParams&
+  getParams()
+  {
+    return mParams;
+  };
+
+  COMMAND
+  getNextCommand()
+  {
+    mIndex++;
+    return mIndex < mLength ? mCommands[mIndex] : NULL;
+  };
+
+  ERROR_CALLBACK
+  getErrorCallback() const
+  {
+    return mError;
+  };
+
+private:
+  uint32_t mIndex;
+  NetworkParams mParams;
+  COMMAND* mCommands;
+  uint32_t mLength;
+  ERROR_CALLBACK mError;
+};
+
+class NetworkUtils MOZ_FINAL
+{
+public:
+  NetworkUtils(POSTMESSAGE post);
+  ~NetworkUtils();
+
+  void ExecuteCommand(NetworkParams aOptions);
+  void onNetdMessage(const mozilla::ipc::NetdCommand& aCommand);
+
+  bool setDNS(NetworkParams& aOptions);
+  bool setDefaultRouteAndDNS(NetworkParams& aOptions);
+  bool addHostRoute(NetworkParams& aOptions);
+  bool removeDefaultRoute(NetworkParams& aOptions);
+  bool removeHostRoute(NetworkParams& aOptions);
+  bool removeHostRoutes(NetworkParams& aOptions);
+  bool removeNetworkRoute(NetworkParams& aOptions);
+  bool getNetworkInterfaceStats(NetworkParams& aOptions);  
+  bool setNetworkInterfaceAlarm(NetworkParams& aOptions);
+  bool enableNetworkInterfaceAlarm(NetworkParams& aOptions);
+  bool disableNetworkInterfaceAlarm(NetworkParams& aOptions);
+  bool setWifiOperationMode(NetworkParams& aOptions);
+  bool setDhcpServer(NetworkParams& aOptions);
+  bool setWifiTethering(NetworkParams& aOptions);
+  bool setUSBTethering(NetworkParams& aOptions);
+  bool enableUsbRndis(NetworkParams& aOptions);
+  bool updateUpStream(NetworkParams& aOptions);
+
+  POSTMESSAGE mPostCallback;
+  nsAutoPtr<NetUtils> mNetUtils;
+
+private:
+  void checkUsbRndisState(NetworkParams& aOptions);
+
+  void dumpParams(NetworkParams& aOptions, const char* aType);
+};
+
+#endif
diff --git a/dom/system/gonk/NetworkWorker.cpp b/dom/system/gonk/NetworkWorker.cpp
new file mode 100644
index 0000000..1a71fa1
--- /dev/null
+++ b/dom/system/gonk/NetworkWorker.cpp
@@ -0,0 +1,257 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "NetworkWorker.h"
+#include "NetworkUtils.h"
+#include <nsThreadUtils.h>
+#include "mozilla/ModuleUtils.h"
+#include "mozilla/ClearOnShutdown.h"
+#include "nsXULAppAPI.h"
+#include "nsCxPusher.h"
+
+// TODO : this is only temp for debug
+#include <android/log.h>
+//using namespace android;
+#define WORKER_LOG(args...)  __android_log_print(ANDROID_LOG_INFO, "Dimi" , ## args)
+
+#define NS_NETWORKWORKER_CID \
+  { 0x6df093e1, 0x8127, 0x4fa7, {0x90, 0x13, 0xa3, 0xaa, 0xa7, 0x79, 0xbb, 0xdd} }
+
+using namespace mozilla;
+using namespace mozilla::dom;
+using namespace mozilla::ipc;
+
+namespace mozilla {
+
+// The singleton Wifi service, to be used on the main thread.
+StaticRefPtr<NetworkWorker> gNetworkWorker;
+
+// The singleton supplicant class, that can be used on any thread.
+static nsAutoPtr<NetworkUtils> gNetworkUtils;
+
+// Runnable used dispatch command result on the main thread.
+class NetworkResultDispatcher : public nsRunnable
+{
+public:
+  NetworkResultDispatcher(const NetworkResultOptions& aResult)
+  {
+    MOZ_ASSERT(!NS_IsMainThread());
+
+#define COPY_FIELD(prop) mResult.prop = aResult.prop;
+    COPY_FIELD(mId)
+    COPY_FIELD(mRet)
+    COPY_FIELD(mBroadcast)
+    COPY_FIELD(mTopic)
+    COPY_FIELD(mReason)
+    COPY_FIELD(mResultCode)
+    COPY_FIELD(mResultReason)
+    COPY_FIELD(mError)
+    COPY_FIELD(mRxBytes)
+    COPY_FIELD(mTxBytes)
+    COPY_FIELD(mDate)
+    COPY_FIELD(mEnable)
+    COPY_FIELD(mResult)
+    COPY_FIELD(mSuccess)
+    COPY_FIELD(mCurExternalIfname)
+    COPY_FIELD(mCurInternalIfname)
+#undef COPY_FIELD
+  }
+
+  NS_IMETHOD Run()
+  {
+    MOZ_ASSERT(NS_IsMainThread());
+    gNetworkWorker->DispatchNetworkResult(mResult);
+    return NS_OK;
+  }
+private:
+  NetworkResultOptions mResult;
+};
+
+// Runnable used dispatch netd command on the worker thread.
+class NetworkCommandDispatcher : public nsRunnable
+{
+public:
+  NetworkCommandDispatcher(const NetworkParams& aParams)
+    : mParams(aParams)
+  {
+    MOZ_ASSERT(NS_IsMainThread());
+  }
+
+  NS_IMETHOD Run()
+  {
+    gNetworkUtils->ExecuteCommand(mParams);
+    return NS_OK;
+  }
+private:
+  NetworkParams mParams;
+};
+
+// Runnable used dispatch netd result on the worker thread.
+class NetdEventRunnable : public nsRunnable
+{
+public:
+  NetdEventRunnable(const NetdCommand* aMessage)
+  {
+    memcpy(&mCommand, aMessage, sizeof(NetdCommand));
+  }
+
+  NS_IMETHOD Run()
+  {
+    gNetworkUtils->onNetdMessage(mCommand);
+    return NS_OK;
+  }
+
+private:
+  NetdCommand mCommand;
+};
+
+NS_IMPL_ISUPPORTS1(NetworkWorker, nsINetworkWorker)
+
+NetworkWorker::NetworkWorker()
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  MOZ_ASSERT(!gNetworkWorker);
+}
+
+NetworkWorker::~NetworkWorker()
+{
+  MOZ_ASSERT(!gNetworkWorker);
+}
+
+already_AddRefed<NetworkWorker>
+NetworkWorker::FactoryCreate()
+{
+  if (XRE_GetProcessType() != GeckoProcessType_Default) {
+    return nullptr;
+  }
+
+  MOZ_ASSERT(NS_IsMainThread());
+
+  if (!gNetworkWorker) {
+    gNetworkWorker = new NetworkWorker();
+    ClearOnShutdown(&gNetworkWorker);
+
+    gNetworkUtils = new NetworkUtils(NetworkWorker::NotifyResult);
+    ClearOnShutdown(&gNetworkUtils);
+  }
+
+  nsRefPtr<NetworkWorker> worker = gNetworkWorker.get();
+  return worker.forget();
+}
+
+NS_IMETHODIMP
+NetworkWorker::Start(nsINetworkEventListener* aListener)
+{
+  MOZ_ASSERT(NS_IsMainThread());
+  MOZ_ASSERT(aListener);
+
+  nsresult rv;
+
+  StartNetd(gNetworkWorker);
+
+  rv = NS_NewThread(getter_AddRefs(mWorkerThread));
+  if (NS_FAILED(rv)) {
+    NS_WARNING("Can't create network control thread");
+    Shutdown();
+    return NS_ERROR_FAILURE;
+  }
+
+  mListener = aListener;
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+NetworkWorker::Shutdown()
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  StopNetd();
+
+  if (mWorkerThread) {
+    mWorkerThread->Shutdown();
+    mWorkerThread = nullptr;
+  }
+
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+NetworkWorker::PostMessage(const JS::Value& aOptions, JSContext* aCx)
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  NetworkCommandOptions options;
+
+  if (!options.Init(aCx, JS::Handle<JS::Value>::fromMarkedLocation(&aOptions))) {
+    NS_WARNING("Bad dictionary passed to NetworkWorker::SendCommand");
+    return NS_ERROR_FAILURE;
+  }
+
+  // Dispatch the command to the control thread.
+  NetworkParams NetworkParams(options);
+  nsCOMPtr<nsIRunnable> runnable = new NetworkCommandDispatcher(NetworkParams);
+  mWorkerThread->Dispatch(runnable, nsIEventTarget::DISPATCH_NORMAL);
+
+  return NS_OK;
+}
+
+void
+NetworkWorker::DispatchNetworkResult(const NetworkResultOptions& aOptions)
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  mozilla::AutoSafeJSContext cx;
+  JS::RootedValue val(cx);
+
+  if (!aOptions.ToObject(cx, JS::NullPtr(), &val)) {
+    return;
+  }
+
+  // Call the listener with a JS value.
+  mListener->OnEvent(val);
+}
+
+void
+NetworkWorker::MessageReceived(NetdCommand* aMessage)
+{
+  MOZ_ASSERT(NS_IsMainThread());
+
+  nsCOMPtr<nsIRunnable> runnable = new NetdEventRunnable(aMessage);
+  mWorkerThread->Dispatch(runnable, nsIEventTarget::DISPATCH_NORMAL);
+}
+
+// Callback function for worker thread to update result to main thread.
+void 
+NetworkWorker::NotifyResult(NetworkResultOptions& aResult)
+{
+  nsCOMPtr<nsIRunnable> runnable = new NetworkResultDispatcher(aResult);
+  NS_DispatchToMainThread(runnable);
+}
+
+NS_GENERIC_FACTORY_SINGLETON_CONSTRUCTOR(NetworkWorker,
+                                         NetworkWorker::FactoryCreate)
+
+NS_DEFINE_NAMED_CID(NS_NETWORKWORKER_CID);
+
+static const mozilla::Module::CIDEntry kNetworkWorkerCIDs[] = {
+  { &kNS_NETWORKWORKER_CID, false, nullptr, NetworkWorkerConstructor },
+  { nullptr }
+};
+
+static const mozilla::Module::ContractIDEntry kNetworkWorkerContracts[] = {
+  { "@mozilla.org/network/worker;1", &kNS_NETWORKWORKER_CID },
+  { nullptr }
+};
+
+static const mozilla::Module kNetworkWorkerModule = {
+  mozilla::Module::kVersion,
+  kNetworkWorkerCIDs,
+  kNetworkWorkerContracts,
+  nullptr
+};
+
+} // namespace mozilla
+
+NSMODULE_DEFN(NetworkWorkerModule) = &kNetworkWorkerModule;
diff --git a/dom/system/gonk/NetworkWorker.h b/dom/system/gonk/NetworkWorker.h
new file mode 100644
index 0000000..a98fd47
--- /dev/null
+++ b/dom/system/gonk/NetworkWorker.h
@@ -0,0 +1,40 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#ifndef NetworkWorker_h
+#define NetworkWorker_h
+
+#include "mozilla/dom/NetworkOptionsBinding.h"
+#include "mozilla/ipc/Netd.h"
+#include "nsINetworkWorker.h"
+#include "nsCOMPtr.h"
+#include "nsThread.h"
+
+namespace mozilla {
+
+class NetworkWorker MOZ_FINAL : public nsINetworkWorker,
+                                public mozilla::ipc::NetdConsumer
+{
+public:
+  NS_DECL_ISUPPORTS
+  NS_DECL_NSINETWORKWORKER
+
+  static already_AddRefed<NetworkWorker> FactoryCreate();
+
+  void DispatchNetworkResult(const mozilla::dom::NetworkResultOptions& aOptions);
+  void MessageReceived(mozilla::ipc::NetdCommand* aMessage);
+
+private:
+  NetworkWorker();
+  ~NetworkWorker();
+
+  static void NotifyResult(mozilla::dom::NetworkResultOptions& aResult);
+
+  nsCOMPtr<nsIThread> mWorkerThread;
+  nsCOMPtr<nsINetworkEventListener> mListener;
+};
+
+} // namespace mozilla
+
+#endif  // NetworkWorker_h
diff --git a/dom/system/gonk/SystemWorkerManager.cpp b/dom/system/gonk/SystemWorkerManager.cpp
index 3f22a09..2e98d77 100644
--- a/dom/system/gonk/SystemWorkerManager.cpp
+++ b/dom/system/gonk/SystemWorkerManager.cpp
@@ -24,7 +24,6 @@
 
 #include "jsfriendapi.h"
 #include "mozilla/dom/workers/Workers.h"
-#include "mozilla/ipc/Netd.h"
 #include "AutoMounter.h"
 #include "TimeZoneSettingObserver.h"
 #include "AudioManager.h"
@@ -57,150 +56,6 @@ NS_DEFINE_CID(kNetworkServiceCID, NS_INETWORKSERVICE_IID);
 // Doesn't carry a reference, we're owned by services.
 SystemWorkerManager *gInstance = nullptr;
 
-bool
-DoNetdCommand(JSContext *cx, unsigned argc, JS::Value *vp)
-{
-  NS_ASSERTION(!NS_IsMainThread(), "Expecting to be on the worker thread");
-
-  if (argc != 1) {
-    JS_ReportError(cx, "Expecting a single argument with the Netd message");
-    return false;
-  }
-
-  JS::Value v = JS_ARGV(cx, vp)[0];
-
-  JSAutoByteString abs;
-  void *data;
-  size_t size;
-  if (JSVAL_IS_STRING(v)) {
-    JSString *str = JSVAL_TO_STRING(v);
-    if (!abs.encodeUtf8(cx, str)) {
-      return false;
-    }
-
-    size = abs.length();
-    if (!size) {
-      JS_ReportError(cx, "Command length is zero");
-      return false;
-    }
-
-    data = abs.ptr();
-    if (!data) {
-      JS_ReportError(cx, "Command string is empty");
-      return false;
-    }
-  } else if (!JSVAL_IS_PRIMITIVE(v)) {
-    JSObject *obj = JSVAL_TO_OBJECT(v);
-    if (!JS_IsTypedArrayObject(obj)) {
-      JS_ReportError(cx, "Object passed in wasn't a typed array");
-      return false;
-    }
-
-    uint32_t type = JS_GetArrayBufferViewType(obj);
-    if (type != js::ArrayBufferView::TYPE_INT8 &&
-        type != js::ArrayBufferView::TYPE_UINT8 &&
-        type != js::ArrayBufferView::TYPE_UINT8_CLAMPED) {
-      JS_ReportError(cx, "Typed array data is not octets");
-      return false;
-    }
-
-    size = JS_GetTypedArrayByteLength(obj);
-    if (!size) {
-      JS_ReportError(cx, "Typed array byte length is zero");
-      return false;
-    }
-
-    data = JS_GetArrayBufferViewData(obj);
-    if (!data) {
-      JS_ReportError(cx, "Array buffer view data is NULL");
-      return false;
-    }
-  } else {
-    JS_ReportError(cx,
-                   "Incorrect argument. Expecting a string or a typed array");
-    return false;
-  }
-
-  // Reserve one space for '\0'.
-  if (size > MAX_COMMAND_SIZE - 1 || size <= 0) {
-    JS_ReportError(cx, "Passed-in data size is invalid");
-    return false;
-  }
-
-  NetdCommand* command = new NetdCommand();
-
-  memcpy(command->mData, data, size);
-  // Include the null terminate to the command to make netd happy.
-  command->mData[size] = 0;
-  command->mSize = size + 1;
-  SendNetdCommand(command);
-  return true;
-}
-
-class ConnectWorkerToNetd : public WorkerTask
-{
-public:
-  virtual bool RunTask(JSContext *aCx);
-};
-
-bool
-ConnectWorkerToNetd::RunTask(JSContext *aCx)
-{
-  // Set up the DoNetdCommand on the function for worker <--> Netd process
-  // communication.
-  NS_ASSERTION(!NS_IsMainThread(), "Expecting to be on the worker thread");
-  NS_ASSERTION(!JS_IsRunning(aCx), "Are we being called somehow?");
-  JSObject *workerGlobal = JS::CurrentGlobalOrNull(aCx);
-  return !!JS_DefineFunction(aCx, workerGlobal, "postNetdCommand",
-                             DoNetdCommand, 1, 0);
-}
-
-class NetdReceiver : public NetdConsumer
-{
-  class DispatchNetdEvent : public WorkerTask
-  {
-  public:
-    DispatchNetdEvent(NetdCommand *aMessage)
-      : mMessage(aMessage)
-    { }
-
-    virtual bool RunTask(JSContext *aCx);
-
-  private:
-    nsAutoPtr<NetdCommand> mMessage;
-  };
-
-public:
-  NetdReceiver(WorkerCrossThreadDispatcher *aDispatcher)
-    : mDispatcher(aDispatcher)
-  { }
-
-  virtual void MessageReceived(NetdCommand *aMessage) {
-    nsRefPtr<DispatchNetdEvent> dre(new DispatchNetdEvent(aMessage));
-    if (!mDispatcher->PostTask(dre)) {
-      NS_WARNING("Failed to PostTask to net worker");
-    }
-  }
-
-private:
-  nsRefPtr<WorkerCrossThreadDispatcher> mDispatcher;
-};
-
-bool
-NetdReceiver::DispatchNetdEvent::RunTask(JSContext *aCx)
-{
-  JSObject *obj = JS::CurrentGlobalOrNull(aCx);
-
-  JSObject *array = JS_NewUint8Array(aCx, mMessage->mSize);
-  if (!array) {
-    return false;
-  }
-
-  memcpy(JS_GetUint8ArrayData(array), mMessage->mData, mMessage->mSize);
-  JS::Value argv[] = { OBJECT_TO_JSVAL(array) };
-  return JS_CallFunctionName(aCx, obj, "onNetdMessage", NS_ARRAY_LENGTH(argv),
-                             argv, argv);
-}
 
 } // anonymous namespace
 
@@ -278,7 +133,6 @@ SystemWorkerManager::Shutdown()
   NfcConsumer::Shutdown();
 #endif
 
-  StopNetd();
   mNetdWorker = nullptr;
 
   nsCOMPtr<nsIWifi> wifi(do_QueryInterface(mWifiWorker));
@@ -392,29 +246,6 @@ SystemWorkerManager::InitNetd(JSContext *cx)
   nsCOMPtr<nsIWorkerHolder> worker = do_GetService(kNetworkServiceCID);
   NS_ENSURE_TRUE(worker, NS_ERROR_FAILURE);
 
-  JS::Value workerval;
-  nsresult rv = worker->GetWorker(&workerval);
-  NS_ENSURE_SUCCESS(rv, rv);
-  NS_ENSURE_TRUE(!JSVAL_IS_PRIMITIVE(workerval), NS_ERROR_UNEXPECTED);
-
-  JSAutoCompartment ac(cx, JSVAL_TO_OBJECT(workerval));
-
-  WorkerCrossThreadDispatcher *wctd =
-    GetWorkerCrossThreadDispatcher(cx, workerval);
-  if (!wctd) {
-    NS_WARNING("Failed to GetWorkerCrossThreadDispatcher for netd");
-    return NS_ERROR_FAILURE;
-  }
-
-  nsRefPtr<ConnectWorkerToNetd> connection = new ConnectWorkerToNetd();
-  if (!wctd->PostTask(connection)) {
-    NS_WARNING("Failed to connect worker to netd");
-    return NS_ERROR_UNEXPECTED;
-  }
-
-  // Now that we're set up, connect ourselves to the Netd process.
-  mozilla::RefPtr<NetdReceiver> receiver = new NetdReceiver(wctd);
-  StartNetd(receiver);
   mNetdWorker = worker;
   return NS_OK;
 }
diff --git a/dom/system/gonk/moz.build b/dom/system/gonk/moz.build
index 4969f1b..ef92f5d 100644
--- a/dom/system/gonk/moz.build
+++ b/dom/system/gonk/moz.build
@@ -19,6 +19,7 @@ XPIDL_SOURCES += [
     'nsINetworkInterfaceListService.idl',
     'nsINetworkManager.idl',
     'nsINetworkService.idl',
+    'nsINetworkWorker.idl',
     'nsISystemWorkerManager.idl',
     'nsIVolume.idl',
     'nsIVolumeMountLock.idl',
@@ -40,6 +41,8 @@ SOURCES += [
     'AutoMounter.cpp',
     'AutoMounterSetting.cpp',
     'GonkGPSGeolocationProvider.cpp',
+    'NetworkUtils.cpp',
+    'NetworkWorker.cpp',
     'nsVolume.cpp',
     'nsVolumeMountLock.cpp',
     'nsVolumeService.cpp',
@@ -68,7 +71,6 @@ EXTRA_PP_COMPONENTS += [
     'NetworkService.js',
 ]
 EXTRA_JS_MODULES += [
-    'net_worker.js',
     'systemlibs.js',
 ]
 
diff --git a/dom/system/gonk/nsINetworkWorker.idl b/dom/system/gonk/nsINetworkWorker.idl
new file mode 100644
index 0000000..8fe19be
--- /dev/null
+++ b/dom/system/gonk/nsINetworkWorker.idl
@@ -0,0 +1,18 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+ * License, v. 2.0. If a copy of the MPL was not distributed with this
+ * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+#include "nsISupports.idl"
+
+[scriptable, uuid(98e31d3b-6cad-4cab-b4b3-4afff566ea65)]
+interface nsINetworkEventListener : nsISupports {
+  void onEvent(in jsval result);
+};
+
+[scriptable, uuid(f9d9c694-0aac-4f9a-98ac-7788f954239a)]
+interface nsINetworkWorker : nsISupports {
+  void start(in nsINetworkEventListener listener);
+  void shutdown();
+  [implicit_jscontext]
+  void postMessage(in jsval options);
+};
diff --git a/dom/webidl/NetworkOptions.webidl b/dom/webidl/NetworkOptions.webidl
new file mode 100644
index 0000000..0ffad34
--- /dev/null
+++ b/dom/webidl/NetworkOptions.webidl
@@ -0,0 +1,84 @@
+/* This Source Code Form is subject to the terms of the Mozilla Public
+* License, v. 2.0. If a copy of the MPL was not distributed with this file,
+* You can obtain one at http://mozilla.org/MPL/2.0/. */
+
+/**
+* This dictionnary holds the parameters sent to the network worker.
+*/
+dictionary NetworkCommandOptions
+{
+  long id = 0;                      // opaque id.
+  DOMString cmd = "";               // the command name.
+  DOMString ifname;                 // for "removeNetworkRoute", "setDNS",
+                                    //     "setDefaultRouteAndDNS", "removeDefaultRoute"
+                                    //     "addHostRoute", "removeHostRoute"
+                                    //     "removeHostRoutes".
+  DOMString ip;                     // for "removeNetworkRoute", "setWifiTethering".
+  DOMString netmask;                // for "removeNetworkRoute".
+  DOMString dns1_str;               // for "setDNS", "setDefaultRouteAndDNS".
+  DOMString dns2_str;               // for "setDNS", "setDefaultRouteAndDNS".
+  DOMString oldIfname;              // for "setDefaultRouteAndDNS".
+  DOMString gateway_str;            // for "setDefaultRouteAndDNS".
+  DOMString gateway;                // for "addHostRoute", "removeHostRoute".
+  sequence<DOMString> hostnames;    // for "addHostRoute", "removeHostRoute".
+  DOMString mode;                   // for "setWifiOperationMode".
+  boolean report;                   // for "setWifiOperationMode".
+  boolean isAsync;                  // for "setWifiOperationMode".
+  boolean enabled;                  // for "setDhcpServer".
+  DOMString wifictrlinterfacename;  // for "setWifiTethering".
+  DOMString internalIfname;         // for "setWifiTethering".
+  DOMString externalIfname;         // for "setWifiTethering".
+  boolean enable;                   // for "setWifiTethering".
+  DOMString ssid;                   // for "setWifiTethering".
+  DOMString security;               // for "setWifiTethering".
+  DOMString key;                    // for "setWifiTethering".
+  DOMString prefix;                 // for "setWifiTethering", "setDhcpServer".
+  DOMString link;                   // for "setWifiTethering", "setDhcpServer".
+  sequence<DOMString> interfaceList;// for "setWifiTethering".
+  DOMString wifiStartIp;            // for "setWifiTethering".
+  DOMString wifiEndIp;              // for "setWifiTethering".
+  DOMString usbStartIp;             // for "setWifiTethering".
+  DOMString usbEndIp;               // for "setWifiTethering".
+  DOMString dns1;                   // for "setWifiTethering".
+  DOMString dns2;                   // for "setWifiTethering".
+  float rxBytes;                    // for "getNetworkInterfaceStats".
+  float txBytes;                    // for "getNetworkInterfaceStats".
+  DOMString date;                   // for "getNetworkInterfaceStats".
+  long threshold;                   // for "setNetworkInterfaceAlarm", 
+                                    //     "enableNetworkInterfaceAlarm".
+  DOMString startIp;                // for "setDhcpServer".
+  DOMString endIp;                  // for "setDhcpServer".
+  DOMString serverIp;               // for "setDhcpServer".
+  DOMString maskLength;             // for "setDhcpServer".
+  DOMString preInternalIfname;      // for "updateUpStream".
+  DOMString preExternalIfname;      // for "updateUpStream".
+  DOMString curInternalIfname;      // for "updateUpStream".
+  DOMString curExternalIfname;      // for "updateUpStream".
+};
+
+/**
+* This dictionnary holds the parameters sent back to NetworkService.js
+*/
+dictionary NetworkResultOptions
+{
+  long id = 0;                              // opaque id.
+  boolean ret = false;                      // for not async command.
+  boolean broadcast = false;                // for netd broadcast message.
+  DOMString topic = "";                     // for netd broadcast message.
+  DOMString reason = "";                    // for netd broadcast message.
+
+  long resultCode = 0;
+  DOMString resultReason = "";
+
+  boolean error = false;
+
+  float rxBytes = -1;                       // for "getNetworkInterfaceStats".
+  float txBytes = -1;                       // for "getNetworkInterfaceStats".
+  DOMString date = "";                      // for "getNetworkInterfaceStats".
+  boolean enable = false;                   // for "setWifiTethering", "setUSBTethering"
+                                            //     "enableUsbRndis".
+  boolean result = false;                   // for "enableUsbRndis".
+  boolean success = false;                  // for "setDhcpServer".
+  DOMString curExternalIfname = "";         // for "updateUpStream".
+  DOMString curInternalIfname = "";         // for "updateUpStream".
+};
diff --git a/dom/webidl/moz.build b/dom/webidl/moz.build
index 2ac9fe5..01c33b0 100644
--- a/dom/webidl/moz.build
+++ b/dom/webidl/moz.build
@@ -233,6 +233,7 @@ WEBIDL_FILES = [
     'MutationEvent.webidl',
     'MutationObserver.webidl',
     'NetDashboard.webidl',
+    'NetworkOptions.webidl',
     'Node.webidl',
     'NodeFilter.webidl',
     'NodeIterator.webidl',
diff --git a/dom/wifi/NetUtils.cpp b/dom/wifi/NetUtils.cpp
deleted file mode 100644
index 12ced65..0000000
--- a/dom/wifi/NetUtils.cpp
+++ /dev/null
@@ -1,139 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-#include "NetUtils.h"
-#include <dlfcn.h>
-#include <errno.h>
-#include <cutils/properties.h>
-#include "prinit.h"
-#include "mozilla/Assertions.h"
-#include "nsDebug.h"
-
-static void* sNetUtilsLib;
-static PRCallOnceType sInitNetUtilsLib;
-
-static PRStatus
-InitNetUtilsLib()
-{
-  sNetUtilsLib = dlopen("/system/lib/libnetutils.so", RTLD_LAZY);
-  // We might fail to open the hardware lib. That's OK.
-  return PR_SUCCESS;
-}
-
-static void*
-GetNetUtilsLibHandle()
-{
-  PR_CallOnce(&sInitNetUtilsLib, InitNetUtilsLib);
-  return sNetUtilsLib;
-}
-
-// static
-void*
-NetUtils::GetSharedLibrary()
-{
-  void* netLib = GetNetUtilsLibHandle();
-  if (!netLib) {
-    NS_WARNING("No /system/lib/libnetutils.so");
-  }
-  return netLib;
-}
-
-// static
-int32_t
-NetUtils::SdkVersion()
-{
-  char propVersion[PROPERTY_VALUE_MAX];
-  property_get("ro.build.version.sdk", propVersion, "0");
-  int32_t version = strtol(propVersion, nullptr, 10);
-  return version;
-}
-
-DEFINE_DLFUNC(ifc_enable, int32_t, const char*)
-DEFINE_DLFUNC(ifc_disable, int32_t, const char*)
-DEFINE_DLFUNC(ifc_configure, int32_t, const char*, in_addr_t, uint32_t,
-              in_addr_t, in_addr_t, in_addr_t)
-DEFINE_DLFUNC(ifc_reset_connections, int32_t, const char*, const int32_t)
-DEFINE_DLFUNC(dhcp_stop, int32_t, const char*)
-
-int32_t NetUtils::do_ifc_enable(const char *ifname)
-{
-  USE_DLFUNC(ifc_enable)
-  return ifc_enable(ifname);
-}
-
-int32_t NetUtils::do_ifc_disable(const char *ifname)
-{
-  USE_DLFUNC(ifc_disable)
-  return ifc_disable(ifname);
-}
-
-int32_t NetUtils::do_ifc_configure(const char *ifname,
-                                       in_addr_t address,
-                                       uint32_t prefixLength,
-                                       in_addr_t gateway,
-                                       in_addr_t dns1,
-                                       in_addr_t dns2)
-{
-  USE_DLFUNC(ifc_configure)
-  int32_t ret = ifc_configure(ifname, address, prefixLength, gateway, dns1, dns2);
-  return ret;
-}
-
-int32_t NetUtils::do_ifc_reset_connections(const char *ifname,
-                                               const int32_t resetMask)
-{
-  USE_DLFUNC(ifc_reset_connections)
-  return ifc_reset_connections(ifname, resetMask);
-}
-
-int32_t NetUtils::do_dhcp_stop(const char *ifname)
-{
-  USE_DLFUNC(dhcp_stop)
-  return dhcp_stop(ifname);
-}
-
-int32_t NetUtils::do_dhcp_do_request(const char *ifname,
-                                         char *ipaddr,
-                                         char *gateway,
-                                         uint32_t *prefixLength,
-                                         char *dns1,
-                                         char *dns2,
-                                         char *server,
-                                         uint32_t  *lease,
-                                         char* vendorinfo)
-{
-  int32_t ret = -1;
-  uint32_t sdkVersion = SdkVersion();
-
-  if (sdkVersion == 15) {
-    // ICS
-    // http://androidxref.com/4.0.4/xref/system/core/libnetutils/dhcp_utils.c#149
-    DEFINE_DLFUNC(dhcp_do_request, int32_t, const char*, char*, char*,  uint32_t*, char*, char*, char*, uint32_t*)
-    USE_DLFUNC(dhcp_do_request)
-    vendorinfo[0] = '\0';
-
-    ret = dhcp_do_request(ifname, ipaddr, gateway, prefixLength, dns1, dns2,
-                          server, lease);
-  } else if (sdkVersion == 16 || sdkVersion == 17) {
-    // JB 4.1 and 4.2
-    // http://androidxref.com/4.1.2/xref/system/core/libnetutils/dhcp_utils.c#175
-    // http://androidxref.com/4.2.2_r1/xref/system/core/include/netutils/dhcp.h#26
-    DEFINE_DLFUNC(dhcp_do_request, int32_t, const char*, char*, char*,  uint32_t*, char*, char*, char*, uint32_t*, char*)
-    USE_DLFUNC(dhcp_do_request)
-    ret = dhcp_do_request(ifname, ipaddr, gateway, prefixLength, dns1, dns2,
-                          server, lease, vendorinfo);
-  } else if (sdkVersion == 18) {
-    // JB 4.3
-    // http://androidxref.com/4.3_r2.1/xref/system/core/libnetutils/dhcp_utils.c#181
-    DEFINE_DLFUNC(dhcp_do_request, int32_t, const char*, char*, char*,  uint32_t*, char**, char*, uint32_t*, char*, char*)
-    USE_DLFUNC(dhcp_do_request)
-    char *dns[3] = {dns1, dns2, nullptr};
-    char domains[PROPERTY_VALUE_MAX];
-    ret = dhcp_do_request(ifname, ipaddr, gateway, prefixLength, dns,
-                          server, lease, vendorinfo, domains);
-  } else {
-    NS_WARNING("Unable to perform do_dhcp_request: unsupported sdk version!");
-  }
-  return ret;
-}
diff --git a/dom/wifi/NetUtils.h b/dom/wifi/NetUtils.h
deleted file mode 100644
index 4397fca..0000000
--- a/dom/wifi/NetUtils.h
+++ /dev/null
@@ -1,60 +0,0 @@
-/* This Source Code Form is subject to the terms of the Mozilla Public
- * License, v. 2.0. If a copy of the MPL was not distributed with this
- * file, You can obtain one at http://mozilla.org/MPL/2.0/. */
-
-/**
- * Abstraction on top of the network support from libnetutils that we
- * use to set up network connections.
- */
-
-#ifndef NetUtils_h
-#define NetUtils_h
-
-#include "arpa/inet.h"
-
-// Copied from ifc.h
-#define RESET_IPV4_ADDRESSES 0x01
-#define RESET_IPV6_ADDRESSES 0x02
-#define RESET_ALL_ADDRESSES  (RESET_IPV4_ADDRESSES | RESET_IPV6_ADDRESSES)
-
-// Implements netutils functions. No need for an abstract class here since we
-// only have a one sdk specific method (dhcp_do_request)
-class NetUtils
-{
-public:
-  static void* GetSharedLibrary();
-
-  int32_t do_ifc_enable(const char *ifname);
-  int32_t do_ifc_disable(const char *ifname);
-  int32_t do_ifc_configure(const char *ifname,
-                           in_addr_t address,
-                           uint32_t prefixLength,
-                           in_addr_t gateway,
-                           in_addr_t dns1,
-                           in_addr_t dns2);
-  int32_t do_ifc_reset_connections(const char *ifname, const int32_t resetMask);
-  int32_t do_dhcp_stop(const char *ifname);
-  int32_t do_dhcp_do_request(const char *ifname,
-                             char *ipaddr,
-                             char *gateway,
-                             uint32_t *prefixLength,
-                             char *dns1,
-                             char *dns2,
-                             char *server,
-                             uint32_t  *lease,
-                             char* vendorinfo);
-
-  static int32_t SdkVersion();
-};
-
-// Defines a function type with the right arguments and return type.
-#define DEFINE_DLFUNC(name, ret, args...) typedef ret (*FUNC##name)(args);
-
-// Set up a dlsymed function ready to use.
-#define USE_DLFUNC(name)                                                      \
-  FUNC##name name = (FUNC##name) dlsym(GetSharedLibrary(), #name);            \
-  if (!name) {                                                                \
-    MOZ_ASSUME_UNREACHABLE("Symbol not found in shared library : " #name);         \
-  }
-
-#endif // NetUtils_h
diff --git a/dom/wifi/WifiUtils.cpp b/dom/wifi/WifiUtils.cpp
index 283aecb..8ec4504 100644
--- a/dom/wifi/WifiUtils.cpp
+++ b/dom/wifi/WifiUtils.cpp
@@ -7,7 +7,7 @@
 #include <errno.h>
 #include "prinit.h"
 #include "js/CharacterEncoding.h"
-#include "NetUtils.h"
+#include "mozilla/dom/network/NetUtils.h"
 
 using namespace mozilla::dom;
 
diff --git a/dom/wifi/WifiUtils.h b/dom/wifi/WifiUtils.h
index 6a82cef..868646e 100644
--- a/dom/wifi/WifiUtils.h
+++ b/dom/wifi/WifiUtils.h
@@ -13,7 +13,7 @@
 #include "nsString.h"
 #include "nsAutoPtr.h"
 #include "mozilla/dom/WifiOptionsBinding.h"
-#include "NetUtils.h"
+#include "mozilla/dom/network/NetUtils.h"
 #include "nsCxPusher.h"
 
 // Needed to add a copy constructor to WifiCommandOptions.
diff --git a/dom/wifi/moz.build b/dom/wifi/moz.build
index c6c8a54..d09431b 100644
--- a/dom/wifi/moz.build
+++ b/dom/wifi/moz.build
@@ -27,7 +27,6 @@ EXTRA_JS_MODULES += [
 
 if CONFIG['MOZ_WIDGET_TOOLKIT'] == 'gonk':
     SOURCES = [
-        'NetUtils.cpp',
         'WifiProxyService.cpp',
         'WifiUtils.cpp',
     ]
diff --git a/toolkit/library/nsStaticXULComponents.cpp b/toolkit/library/nsStaticXULComponents.cpp
index ddc0699..8b3ec9a 100644
--- a/toolkit/library/nsStaticXULComponents.cpp
+++ b/toolkit/library/nsStaticXULComponents.cpp
@@ -240,6 +240,7 @@
     GIO_MODULE                               \
     SYNTH_PICO_MODULE                        \
     MODULE(DiskSpaceWatcherModule)           \
+    MODULE(NetworkWorkerModule)              \
     /* end of list */
 
 #define MODULE(_name) \
-- 
1.7.9.5

